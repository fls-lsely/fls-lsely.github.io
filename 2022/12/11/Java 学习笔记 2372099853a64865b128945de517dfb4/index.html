<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java基础语法（面向过程）在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 学习笔记">
<meta property="og:url" content="http://example.com/2022/12/11/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202372099853a64865b128945de517dfb4/index.html">
<meta property="og:site_name" content="lselyの博客">
<meta property="og:description" content="Java基础语法（面向过程）在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png">
<meta property="og:image" content="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523263309.png">
<meta property="og:image" content="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523264595.jpg">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/16566539-672ab962ae6dc500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp">
<meta property="og:image" content="https://i0.hdslb.com/bfs/album/5884577601a5ab1aabe10ee95696557b8d3b5338.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-12-11T07:57:34.000Z">
<meta property="article:modified_time" content="2022-12-11T09:58:41.980Z">
<meta property="article:author" content="lsely">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png">


<link rel="canonical" href="http://example.com/2022/12/11/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202372099853a64865b128945de517dfb4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/12/11/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202372099853a64865b128945de517dfb4/","path":"2022/12/11/Java 学习笔记 2372099853a64865b128945de517dfb4/","title":"Java 学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 学习笔记 | lselyの博客</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="lselyの博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">lselyの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">勤勤恳恳写代码，慵慵懒懒摆摆烂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">1</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">Java基础语法（面向过程）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.1.</span> <span class="nav-text">变量和关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.1.2.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.1.4.</span> <span class="nav-text">注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.2.1.</span> <span class="nav-text">计算机中的二进制表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">计算机中的加减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81"><span class="nav-number">1.2.3.</span> <span class="nav-text">原码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E7%A0%81"><span class="nav-number">1.2.4.</span> <span class="nav-text">反码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81"><span class="nav-number">1.2.5.</span> <span class="nav-text">补码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.6.</span> <span class="nav-text">整数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.7.</span> <span class="nav-text">字符类型和字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.8.</span> <span class="nav-text">小数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.9.</span> <span class="nav-text">布尔类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.1.</span> <span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">显示类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87"><span class="nav-number">1.3.3.</span> <span class="nav-text">数据类型自动提升</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.1.</span> <span class="nav-text">赋值和算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.2.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.4.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.4.5.</span> <span class="nav-text">三目运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.</span> <span class="nav-text">选择结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.3.</span> <span class="nav-text">switch语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.4.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.5.</span> <span class="nav-text">for语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.5.6.</span> <span class="nav-text">while循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E5%9F%BA%E7%A1%80-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">面向过程编程实战（基础+算法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">打印九九乘法表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%821000%E4%BB%A5%E5%86%85%E7%9A%84%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">求1000以内的水仙花数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.3.</span> <span class="nav-text">青蛙跳台阶问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A4%9A%E6%80%81-%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">Java对象和多态 （面向对象）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">类的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">方法的定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0"><span class="nav-number">2.2.4.</span> <span class="nav-text">对象设计练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">2.2.5.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.6.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.7.</span> <span class="nav-text">静态变量和静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.8.</span> <span class="nav-text">简述类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">2.2.9.</span> <span class="nav-text">代码块和静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%92%8CStringBuilder%E7%B1%BB"><span class="nav-number">2.2.10.</span> <span class="nav-text">String和StringBuilder类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">包和访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AF%BC%E5%85%A5"><span class="nav-number">2.3.1.</span> <span class="nav-text">包声明和导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5"><span class="nav-number">2.3.2.</span> <span class="nav-text">静态导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.3.</span> <span class="nav-text">访问控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">数组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.4.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">数组的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9Ffor%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.4.3.</span> <span class="nav-text">传统for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach"><span class="nav-number">2.4.4.</span> <span class="nav-text">foreach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.4.5.</span> <span class="nav-text">二维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.4.6.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">2.4.7.</span> <span class="nav-text">可变长参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.8.</span> <span class="nav-text">实战：三大基本排序算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">2.5.</span> <span class="nav-text">封装、继承和多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">2.5.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">2.5.3.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">2.5.4.</span> <span class="nav-text">方法的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.5.5.</span> <span class="nav-text">再谈类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.5.6.</span> <span class="nav-text">instanceof关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.5.7.</span> <span class="nav-text">再谈final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">2.5.8.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.9.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.6.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.6.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.6.2.</span> <span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.6.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.6.4.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.6.5.</span> <span class="nav-text">lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">2.7.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">2.8.</span> <span class="nav-text">基本类型包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">2.8.1.</span> <span class="nav-text">自动装箱和拆箱</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98"><span class="nav-number">2.9.</span> <span class="nav-text">面向对象编程实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%A4%9A%E6%80%81%E8%BF%90%E7%94%A8%EF%BC%89"><span class="nav-number">2.9.1.</span> <span class="nav-text">对象设计（面向对象、多态运用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">2.9.2.</span> <span class="nav-text">二分搜索（搜索算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%81%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%EF%BC%89"><span class="nav-number">2.9.3.</span> <span class="nav-text">快速排序（排序算法、递归分治）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E5%89%AA%E6%9E%9D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-number">2.9.4.</span> <span class="nav-text">0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">Java异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">3.1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">3.1.1.</span> <span class="nav-text">运行时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">3.1.2.</span> <span class="nav-text">编译时异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">3.2.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">异常的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="nav-number">3.4.</span> <span class="nav-text">异常的抛出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">3.5.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%92%8Cfinally%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.6.</span> <span class="nav-text">多重异常捕获和finally关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">Java泛型与集合类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%B0%E8%BF%9B%E6%B3%9B%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">走进泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">泛型的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">5.2.1.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.2.</span> <span class="nav-text">类的泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.3.</span> <span class="nav-text">自定义泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%BC%95%E7%94%A8"><span class="nav-number">5.2.4.</span> <span class="nav-text">泛型引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%95%8C%E9%99%90"><span class="nav-number">5.2.5.</span> <span class="nav-text">泛型的界限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%BB%E7%9F%B3%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.2.6.</span> <span class="nav-text">钻石运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">5.2.7.</span> <span class="nav-text">泛型与多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">5.2.8.</span> <span class="nav-text">多态类型擦除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="nav-number">5.3.</span> <span class="nav-text">数据结构基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">5.3.2.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">5.3.3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">5.3.4.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">5.3.5.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.3.6.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">5.3.7.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">5.3.8.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">5.3.9.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.3.10.</span> <span class="nav-text">满二叉树和完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE"><span class="nav-number">5.3.11.</span> <span class="nav-text">快速查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">5.3.12.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-number">5.3.13.</span> <span class="nav-text">二叉排序树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.3.14.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">5.3.15.</span> <span class="nav-text">红黑树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">认识集合类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88"><span class="nav-number">5.4.1.</span> <span class="nav-text">数组与集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A0%B9%E6%8E%A5%E5%8F%A3Collection"><span class="nav-number">5.4.2.</span> <span class="nav-text">集合根接口Collection</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.</span> <span class="nav-text">集合类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E5%88%97%E8%A1%A8"><span class="nav-number">5.5.1.</span> <span class="nav-text">List列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">5.5.2.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9D%A5%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9"><span class="nav-number">5.5.3.</span> <span class="nav-text">利用代码块来快速添加内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">5.5.4.</span> <span class="nav-text">集合的排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">5.5.5.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">5.5.6.</span> <span class="nav-text">集合的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterable%E5%92%8CIterator%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.5.7.</span> <span class="nav-text">Iterable和Iterator接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E9%9B%86%E5%90%88"><span class="nav-number">5.5.8.</span> <span class="nav-text">Set集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%98%A0%E5%B0%84"><span class="nav-number">5.5.9.</span> <span class="nav-text">Map映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%98%A0%E5%B0%84"><span class="nav-number">5.5.10.</span> <span class="nav-text">什么是映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.5.11.</span> <span class="nav-text">Map接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E5%92%8CLinkedHashMap"><span class="nav-number">5.5.12.</span> <span class="nav-text">HashMap和LinkedHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">5.5.13.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.14.</span> <span class="nav-text">Map的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88Set%E5%8E%9F%E7%90%86"><span class="nav-number">5.5.15.</span> <span class="nav-text">再谈Set原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-8%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.16.</span> <span class="nav-text">JDK1.8新增方法使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-number">5.5.17.</span> <span class="nav-text">集合的嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81Stream%E5%92%8COptional%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.18.</span> <span class="nav-text">流Stream和Optional的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays%E5%92%8CCollections%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.19.</span> <span class="nav-text">Arrays和Collections的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98"><span class="nav-number">5.6.</span> <span class="nav-text">集合类编程实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">5.6.1.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.6.2.</span> <span class="nav-text">重建二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">5.6.3.</span> <span class="nav-text">实现计算器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%88KMP%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">5.6.4.</span> <span class="nav-text">字符串匹配（KMP算法）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-I-O"><span class="nav-number">6.</span> <span class="nav-text">Java I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">6.1.</span> <span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">6.1.1.</span> <span class="nav-text">文件字节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">6.1.2.</span> <span class="nav-text">文件字符流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">6.1.3.</span> <span class="nav-text">File类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">6.2.</span> <span class="nav-text">缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">6.2.1.</span> <span class="nav-text">缓冲字节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">6.2.2.</span> <span class="nav-text">缓冲字符流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">6.3.</span> <span class="nav-text">转换流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">6.4.</span> <span class="nav-text">打印流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">6.5.</span> <span class="nav-text">数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-number">6.6.</span> <span class="nav-text">对象流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-I-O%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98"><span class="nav-number">6.7.</span> <span class="nav-text">Java I&#x2F;O编程实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.7.1.</span> <span class="nav-text">图书管理系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">Java多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="nav-number">7.1.</span> <span class="nav-text">线程的创建和启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="nav-number">7.2.</span> <span class="nav-text">线程的休眠和中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">7.3.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A4%BC%E8%AE%A9%E5%92%8C%E5%8A%A0%E5%85%A5"><span class="nav-number">7.4.</span> <span class="nav-text">线程的礼让和加入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">7.5.</span> <span class="nav-text">线程锁和线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%AC%E5%BF%B5%E7%A0%B4%E6%A1%88"><span class="nav-number">7.5.1.</span> <span class="nav-text">悬念破案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="nav-number">7.5.2.</span> <span class="nav-text">线程锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">7.5.3.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95"><span class="nav-number">7.5.4.</span> <span class="nav-text">wait和notify方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.5.5.</span> <span class="nav-text">ThreadLocal的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">7.6.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.7.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E9%9B%86%E5%90%88%E7%B1%BB%E5%B9%B6%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="nav-number">7.8.</span> <span class="nav-text">再谈集合类并行方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98"><span class="nav-number">7.9.</span> <span class="nav-text">Java多线程编程实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">7.9.1.</span> <span class="nav-text">生产者与消费者</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.</span> <span class="nav-text">Java反射和注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">8.1.</span> <span class="nav-text">Java类加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.2.</span> <span class="nav-text">Class对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88instanceof"><span class="nav-number">8.2.1.</span> <span class="nav-text">再谈instanceof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="nav-number">8.2.2.</span> <span class="nav-text">获取父类信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.3.</span> <span class="nav-text">创建类对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.</span> <span class="nav-text">调用类的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">8.5.</span> <span class="nav-text">修改类的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="nav-number">8.6.</span> <span class="nav-text">自定义ClassLoader加载类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.7.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E8%AE%BE%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.7.1.</span> <span class="nav-text">预设注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.7.2.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.7.3.</span> <span class="nav-text">注解的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.7.4.</span> <span class="nav-text">反射获取注解</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lsely"
      src="/images/v2-4cfc15fe7744502c6102bf2695d828af_xl.jpg">
  <p class="site-author-name" itemprop="name">lsely</p>
  <div class="site-description" itemprop="description">前进！不择手段的前进！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/lsely-87" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lsely-87" rel="noopener" target="_blank">知乎</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202372099853a64865b128945de517dfb4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-4cfc15fe7744502c6102bf2695d828af_xl.jpg">
      <meta itemprop="name" content="lsely">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lselyの博客">
      <meta itemprop="description" content="前进！不择手段的前进！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java 学习笔记 | lselyの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-12-11 15:57:34 / 修改时间：17:58:41" itemprop="dateCreated datePublished" datetime="2022-12-11T15:57:34+08:00">2022-12-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java基础语法（面向过程）"><a href="#Java基础语法（面向过程）" class="headerlink" title="Java基础语法（面向过程）"></a>Java基础语法（面向过程）</h1><p>在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！</p>
<span id="more"></span>

<h2 id="变量和关键字"><a href="#变量和关键字" class="headerlink" title="变量和关键字"></a><strong>变量和关键字</strong></h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">a = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解）</p>
<p>变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C++–</p>
<p>Java是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！）</p>
<p>定义一个变量的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[类型] [标识符(名字)] = [初始值(可选)]</span><br><span class="line">int a = 10;</span><br></pre></td></tr></table></figure>

<p>注意：标识符不能为以下内容：</p>
<ul>
<li>标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li>
<li>大小写敏感！</li>
<li>不能有空格、@、#、+、-、/ 等符号</li>
<li>应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头</li>
<li>不可以是 true 和 false</li>
<li>不能与Java语言的关键字重名</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><p>常量就是无法修改值的变量，常量的值，只能定义一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">10</span>;  <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！）</p>
<p>这只是final关键字的第一个用法，后面还会有更多的用法。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h3><p>养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我是</span></span><br><span class="line"><span class="comment">* 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 待做标记</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h2><p>Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。</p>
<p>这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了）</p>
<h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a><strong>计算机中的二进制表示</strong></h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p>
<p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p>
<p>现在有4个bit位，最大能够表示多大的数字呢？</p>
<ul>
<li>最小：0000 =&gt; 0</li>
<li>最大：1111 =&gt; 2^3+2^2+2^1+2^0 =&gt; 8 + 4 + 2 + 1 = 15</li>
</ul>
<p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p>
<ul>
<li>最小：1111 =&gt; -(2^2+2^1+2^0) =&gt; -7</li>
<li>最大：0111 =&gt; +(2^2+2^1+2^0) =&gt; +7 =&gt; 7</li>
</ul>
<p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。</p>
<h3 id="计算机中的加减法"><a href="#计算机中的加减法" class="headerlink" title="计算机中的加减法"></a><strong>计算机中的加减法</strong></h3><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p>
<p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p>
<p>我们得创造一种更好的表示方式！于是我们引入了反码：</p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li>
</ul>
<p>经过上面的定义，我们再来进行加减法：</p>
<p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p>
<p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p>
<ul>
<li>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</li>
</ul>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p>
<ul>
<li>正数的补码就是其本身 （不变！）</li>
<li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li>
</ul>
<p>其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p>
<p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p>
<p>所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）</p>
<p><code>以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解</code></p>
<hr>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><strong>整数类型</strong></h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p>
<p>在Java中，整数类型包括以下几个：</p>
<ul>
<li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li>
<li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li>
<li>int 整形（32个bit，也就是4个字节）最常用的类型！</li>
<li>long 长整形（64个bit，也就是8个字节）最后需要添加l或L</li>
</ul>
<p>long都装不下怎么办？BigInteger！</p>
<p>数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例：</p>
<p>0111 + 0001 = 1000 =&gt;  -8（你没看错，就是这样！）</p>
<p>整数还能使用8进制、16进制表示：</p>
<ul>
<li>十进制为15 = 八进制表示为017 = 十六进制表示为 0xF = 二进制表示 1111 (代码里面不能使用二进制！)</li>
</ul>
<h3 id="字符类型和字符串"><a href="#字符类型和字符串" class="headerlink" title="字符类型和字符串"></a><strong>字符类型和字符串</strong></h3><p>在Java中，存在字符类型，它能够代表一个字符：</p>
<ul>
<li>char 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535</li>
<li>使用Unicode表示就是：\u0000 ~ \uffff</li>
</ul>
<p>字符要用单引号扩起来！比如 char c = ‘淦’;</p>
<p>字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符<code>&#39;A&#39;</code>的ASCII码就是数字<code>65</code>，所以，char类型其实可以转换为上面的整数类型。</p>
<p>Java的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名）</p>
<p>既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解）</p>
<p>String就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。</p>
<p>字符串用双引号括起来！比如：String str = “一日三餐没烦恼”;</p>
<h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a><strong>小数类型</strong></h3><p>小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些：</p>
<ul>
<li>float 单精度浮点型 （32bit，4字节）</li>
<li>double 双精度浮点型（64bit，8字节）</li>
</ul>
<p>思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的：</p>
<p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>V = (-1)^S × M × 2^E<br>（1）(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。<br>（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）<br>（3）2^E 表示指数位。（用于移动小数点）</p>
<p>比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。</p>
<p>思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><strong>布尔类型</strong></h3><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><strong>类型转换</strong></h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a><strong>隐式类型转换</strong></h3><p>隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下：</p>
<ul>
<li>byte→short(char)→int→long→float→double</li>
</ul>
<p>问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！</p>
<p>所以，如下的代码就能够正常运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> b;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> f;</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 9.0</span></span><br></pre></td></tr></table></figure>

<h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a><strong>显示类型转换</strong></h3><p>显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 -128</span></span><br></pre></td></tr></table></figure>

<p>为什么结果是-128？精度丢失了！</p>
<ul>
<li>int 类型的128表示：00000000 00000000 00000000 10000000</li>
<li>byte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 =&gt; -128</li>
</ul>
<h3 id="数据类型自动提升"><a href="#数据类型自动提升" class="headerlink" title="数据类型自动提升"></a><strong>数据类型自动提升</strong></h3><p>在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">105</span>;</span><br><span class="line">b = b + <span class="number">1</span>;   <span class="comment">//报错！</span></span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<p>这个特性是由 <strong>Java虚拟机规范</strong> 定义的，也是为了提高运行的效率。其他的特性还有：</p>
<ul>
<li>如果一个操作数是long型，计算结果就是long型</li>
<li>如果一个操作数是float型，计算结果就是float型</li>
<li>如果一个操作数是double型，计算结果就是double型</li>
</ul>
<hr>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h2><h3 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a><strong>赋值和算术运算符</strong></h3><p>赋值运算符<code>=</code>是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>算术运算符也就是我们在小学阶段学习的<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>，分别代表加减乘除还有取余，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;</span><br><span class="line"><span class="comment">//结果为6</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>+</code>还可以用作字符串连接符使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;lbw&quot;</span> + <span class="string">&quot;nb&quot;</span>);  <span class="comment">//lbwnb</span></span><br></pre></td></tr></table></figure>

<p>当然，字符串可以直接连接其他类型，但是会全部当做字符串处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;lbw&quot;</span> + a + b); <span class="comment">//lbw715</span></span><br></pre></td></tr></table></figure>

<p>算术运算符还包括<code>++</code>和<code>--</code>也就是自增和自减，以自增为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line">System.out.println(a); <span class="comment">//输出为11</span></span><br></pre></td></tr></table></figure>

<p>自增自减运算符放在变量的前后的返回值是有区别的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a++);  <span class="comment">//10 （先返回值，再自增）</span></span><br><span class="line">System.out.println(a);   <span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(++a);  <span class="comment">//11 （先自增，再返回值）</span></span><br><span class="line">System.out.println(a);  <span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(b+++a++);  <span class="comment">//猜猜看结果是多少</span></span><br></pre></td></tr></table></figure>

<p>为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括<code>+=</code>、<code>-=</code>、<code>/=</code>、<code>*=</code>、<code>%=</code>，和自增自减类似，先执行运算，再返回结果，同时自身改变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a += <span class="number">2</span>);  <span class="comment">//等价于 a = a + 2</span></span><br></pre></td></tr></table></figure>

<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h3><p>关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt; == <span class="comment">//大于小于等于</span></span><br><span class="line">&gt;= &lt;=  !=  <span class="comment">//大于等于，小于等于，不等于</span></span><br></pre></td></tr></table></figure>

<p>关系运算符一般只用于基本类型的比较，运算结果只能是boolean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">//结果为 true</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h3><p>逻辑运算符两边只能是boolean类型或是关系/逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; <span class="comment">//与运算，要求两边同时为true才能返回true</span></span><br><span class="line">|| <span class="comment">//或运算，要求两边至少要有一个为true才能返回true</span></span><br><span class="line">! <span class="comment">//非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span></span><br></pre></td></tr></table></figure>

<p>实际案例来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b &amp;&amp; a &lt; b;  <span class="comment">//怎么可能同时满足呢</span></span><br><span class="line">System.out.println(x);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b || a &lt;= b;  <span class="comment">//一定有一个满足！</span></span><br><span class="line">System.out.println(x);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> !(a &gt; b); <span class="comment">//对结果进行反转，本来应该是true</span></span><br><span class="line">System.out.println(x); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; <span class="comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span></span><br><span class="line">| <span class="comment">//按位或</span></span><br><span class="line">^ <span class="comment">//按位异或 0 ^ 0 = 0</span></span><br><span class="line">~ <span class="comment">//按位非</span></span><br></pre></td></tr></table></figure>

<p>按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例：</p>
<p>0101 &amp; 0100 = 0100 （只有同时为1对应位才得1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(a &amp; b); <span class="comment">//结果为7</span></span><br></pre></td></tr></table></figure>

<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a><strong>三目运算符</strong></h3><p>三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a &gt; b ? <span class="string">&quot;行&quot;</span> : <span class="string">&quot;不行&quot;</span>;  <span class="comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值</span></span><br><span class="line">System.out.println(<span class="string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="comment">//汉堡做的行不行？不行</span></span><br></pre></td></tr></table></figure>

<p>理解三目运算符，就很容易理解后面的if-else语句了。</p>
<hr>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a><strong>选择结构</strong></h3><p>选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">  <span class="comment">//判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//判断失败执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if的内容执行完成后，后面的内容正常执行</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>else</code>语句不是必须的。</p>
<p>现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//再次判断，如果判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//上面的都没成功，只能走这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，<code>else</code>语句不是必须的。</p>
<p>现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//前提是判断条件1要成功才能进来！</span></span><br><span class="line">  <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//判断成功执行的内容</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//判断失败执行的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>我们不难发现，虽然<code>else-if</code>能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(判断主体)&#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！</p>
<p>为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a><strong>循环结构</strong></h3><p>小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for语句是比较灵活的循环控制语句，一个for语句的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件;循环条件;更新)&#123;</span><br><span class="line">  <span class="comment">//循环执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后，继续执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始条件：循环开始时的条件，一般用于定义控制循环的变量。</li>
<li>循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。</li>
<li>更新：每轮循环结束后都会执行的内容，一般写增量表达式。</li>
</ul>
<p>初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">520</span>;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">//这里的内容将会永远地进行下去！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环在数组时再讲解！</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">  <span class="comment">//循环执行的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//执行内容</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>

<p>一定会先执行do里面的内容，再做判断！</p>
<p>思考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它们的性能谁更高？</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="面向过程编程实战（基础-算法）"><a href="#面向过程编程实战（基础-算法）" class="headerlink" title="面向过程编程实战（基础+算法）"></a><strong>面向过程编程实战（基础+算法）</strong></h2><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a><strong>打印九九乘法表</strong></h3><p>简单：将九九乘法表打印到控制台。</p>
<h3 id="求1000以内的水仙花数"><a href="#求1000以内的水仙花数" class="headerlink" title="求1000以内的水仙花数"></a><strong>求1000以内的水仙花数</strong></h3><p>中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 = 1^3 + 5^3 + 3^3</p>
<h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a><strong>青蛙跳台阶问题</strong></h3><p>困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p>
<p>动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推</p>
<hr>
<p>不对啊，别的教程都讲了数组、方法，怎么我们还没讲就进入面向对象了呢？</p>
<ul>
<li>数组在Java中，并非基本类型，数组是编程不可见的对象类型，学习了面向对象再来理解，会更加容易！</li>
<li>方法在Java中是类具有的属性，所以，在了解了对象类型之后，再来了解方法，就更加简单了！</li>
</ul>
<h1 id="Java对象和多态-（面向对象）"><a href="#Java对象和多态-（面向对象）" class="headerlink" title="Java对象和多态 （面向对象）"></a>Java对象和多态 （面向对象）</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a><strong>面向对象基础</strong></h2><p>面向对象程序设计(Object Oriented Programming)</p>
<p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;你输入了：&quot;</span>+str);</span><br><span class="line">sc.close();</span><br></pre></td></tr></table></figure>

<p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p>
<p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p>
<p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p>
<hr>
<h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a><strong>类的基本结构</strong></h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><strong>成员变量</strong></h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.name = <span class="string">&quot;奥利给&quot;</span>;</span><br><span class="line">    System.out.println(test.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员变量默认带有初始值，也可以自己定义初始值。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a><strong>成员方法</strong></h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//Body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p>
<h3 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h3><p>在类中，我们可以定义自己的方法，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] 方法名称([参数])&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li>
<li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li>
<li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li>
<li>方法体：方法具体要干的事情</li>
<li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li>
</ul>
<p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//缺少retrun语句！</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">//在循环内返回了！和break区别？</span></span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;淦&quot;</span>);   <span class="comment">//还会到这里吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Test</span>().swap(a, b);</span><br><span class="line">    System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//传递的仅仅是值而已！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(B b)</span>&#123;  <span class="comment">//传递的是对象的引用，而不是值</span></span><br><span class="line">    System.out.println(b.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    b.name = <span class="string">&quot;lbw&quot;</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">A</span>().test(b);</span><br><span class="line">    System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法之间可以相互调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//xxxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p>
<hr>
<h3 id="对象设计练习"><a href="#对象设计练习" class="headerlink" title="对象设计练习"></a><strong>对象设计练习</strong></h3><ul>
<li>学生应该具有以下属性：名字、年龄</li>
<li>学生应该具有以下行为：学习、运动、说话</li>
</ul>
<hr>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a><strong>方法的重载</strong></h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;   <span class="comment">//原本的方法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> i)</span>&#123;  <span class="comment">//ok，形参不同</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">byte</span> i)</span>&#123;  <span class="comment">//ok，返回类型和形参都不同</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;  <span class="comment">//错误，仅返回值类型名称不同不能重载</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//只有int支持，不灵活！</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;  <span class="comment">//重写一个double类型的，就支持小数计算了</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">short</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">long</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">char</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">double</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了double&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">float</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了float&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.a(<span class="number">1</span>);   <span class="comment">//直接输入整数</span></span><br><span class="line">        test.a(<span class="number">1.0</span>);  <span class="comment">//直接输入小数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        test.a(s);  <span class="comment">//会对号入座吗？</span></span><br><span class="line">        test.a(<span class="number">1.0F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译结果</span></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;    <span class="comment">//即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译其实就是把我们编译好的class文件变回Java源代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();  <span class="comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span></span><br><span class="line"><span class="comment">// new + 你想要使用的构造方法</span></span><br></pre></td></tr></table></figure>

<p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p>
<p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p>
<p>一般最常用的就是给成员属性赋初始值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        name = &quot;伞兵一号&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;   //形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br><span class="line">        this.name = name;  //通过this指代当前的对象属性，this就代表当前对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//idea 右键快速生成！</span><br></pre></td></tr></table></figure>

<p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p>
<p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//反编译后依然只有我们定义的有参构造！</span><br></pre></td></tr></table></figure>

<p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员变量的初始化始终在构造方法执行之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    String a = &quot;sadasa&quot;;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s = new Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a><strong>静态变量和静态方法</strong></h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    static int a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Student s1 = new Student();</span><br><span class="line">	s1.a = 10;</span><br><span class="line">	Student s2 = new Student();</span><br><span class="line">	System.out.println(s2.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   Student.a = 10;</span><br><span class="line">   System.out.println(Student.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简述类加载机制"><a href="#简述类加载机制" class="headerlink" title="简述类加载机制"></a>简述类加载机制</h3><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p>
<ul>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>new 创建类的实例（隐式加载）</li>
<li>调用类的静态方法</li>
<li>子类初始化时</li>
<li>其他的情况会在讲到反射时介绍</li>
</ul>
<p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    static int a = test();  //直接调用静态方法，只能调用静态方法</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(&quot;构造类对象&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int test()&#123;   //静态方法刚加载时就有了</span><br><span class="line">        System.out.println(&quot;初始化变量a&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    static int a = test();</span><br><span class="line"></span><br><span class="line">    static int test()&#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Student.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p>
<h3 id="代码块和静态代码块"><a href="#代码块和静态代码块" class="headerlink" title="代码块和静态代码块"></a><strong>代码块和静态代码块</strong></h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(&quot;我是构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    static int a;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        a = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Student.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String和StringBuilder类"><a href="#String和StringBuilder类" class="headerlink" title="String和StringBuilder类"></a><strong>String和StringBuilder类</strong></h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p>
<p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;dasdsa&quot;, b = &quot;dasdasdsa&quot;;</span><br><span class="line">String l = a+b;</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure>

<p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result=&quot;String&quot;+&quot;and&quot;; //会被优化成一句！</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1=&quot;String&quot;;</span><br><span class="line">String str2=&quot;and&quot;;</span><br><span class="line">String result=str1+str2;</span><br><span class="line">//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1=&quot;String&quot;;</span><br><span class="line">String str2=&quot;and&quot;;</span><br><span class="line">String result=(new StringBuilder(String.valueOf(str1))).append(str2).toString();</span><br><span class="line">//使用StringBuilder，会采用类似于第一种实现，显然会更快！</span><br></pre></td></tr></table></figure>

<p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = new StringBuilder();</span><br><span class="line">builder</span><br><span class="line">       .append(&quot;a&quot;)</span><br><span class="line">       .append(&quot;bc&quot;)</span><br><span class="line">       .append(&quot;d&quot;);   //链式调用</span><br><span class="line">String str = builder.toString();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a><strong>包和访问控制</strong></h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a><strong>包声明和导入</strong></h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p>
<p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p>
<p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C/C++中的include）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.test.Student;</span><br></pre></td></tr></table></figure>

<p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.test.*</span><br></pre></td></tr></table></figure>

<p>Java默认为我们导入了以下的包，不需要去声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.*</span><br></pre></td></tr></table></figure>

<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a><strong>静态导入</strong></h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import static com.test.ui.Student.test;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态导入不会进行类的初始化！</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p>
<p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int a = 10;   //具有私有访问权限，只能类内部访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Student s = new Student();</span><br><span class="line">    System.out.println(s.a);  //还可以访问吗？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Student.java</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;   //不能添加权限修饰符！只能是default</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a><strong>数组类型</strong></h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&amp;refer=http%3A%2F%2Fimgs.itxueyuan.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632192902&amp;t=7a6d67fc01d0e3ea7816adf951c49605</a></p>
<p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];  //需要new关键字来创建！</span><br><span class="line">String[] arr2 = new String[10];</span><br></pre></td></tr></table></figure>

<p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br><span class="line">System.out.println(arr.length);   //数组有成员变量！</span><br><span class="line">System.out.println(arr.toString());   //数组有成员方法！</span><br></pre></td></tr></table></figure>

<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a><strong>一维数组</strong></h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型[] 变量名称 = new 类型[数组大小];</span><br><span class="line">类型 变量名称n = new 类型[数组大小];  //支持C语言样式，但不推荐！</span><br><span class="line"></span><br><span class="line">类型[] 变量名称 = new 类型[]&#123;...&#125;;  //静态初始化（直接指定值和大小）</span><br><span class="line">类型[] 变量名称 = &#123;...&#125;;   //同上，但是只能在定义时赋值</span><br></pre></td></tr></table></figure>

<p>创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br><span class="line">arr[0] = 626;</span><br><span class="line">System.out.println(arr[0]);</span><br><span class="line">System.out.println(arr[1]);</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">System.out.println(arr.length);  //打印length成员变量的值</span><br></pre></td></tr></table></figure>

<p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = new String[10];</span><br><span class="line">System.out.println(arr[10]);  //出现异常！</span><br><span class="line"></span><br><span class="line">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="line">//	at com.test.Application.main(Application.java:7)</span><br></pre></td></tr></table></figure>

<p>思考：能不能直接修改length的值来实现动态扩容呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">arr.length = 10;</span><br></pre></td></tr></table></figure>

<p>数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    System.out.println(arr[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void test(int[] arr)&#123;</span><br><span class="line">    arr[0] = 2934;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a><strong>数组的遍历</strong></h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p>
<h3 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h3><p>我们很容易就联想到for循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">   System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">for (int i : arr) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&amp;refer=http%3A%2F%2Ffile.elecfans.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632204192&amp;t=52381354d190d09899776f9bb868ef3e</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//三行两列</span><br><span class="line">int[][] arr = &#123; &#123;1, 2&#125;,</span><br><span class="line">                &#123;3, 4&#125;,</span><br><span class="line">                &#123;5, 6&#125;&#125;;</span><br><span class="line">System.out.println(arr[2][1]);</span><br></pre></td></tr></table></figure>

<p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[][]&#123; &#123;1, 2&#125;,</span><br><span class="line">                           &#123;3, 4&#125;,</span><br><span class="line">                           &#123;5, 6&#125;&#125;;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">     for (int j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">          System.out.println(arr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a><strong>多维数组</strong></h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a><strong>可变长参数</strong></h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     test(&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;);    //可变长，最后都会被自动封装成一个数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void test(String... test)&#123;</span><br><span class="line">     System.out.println(test[0]);    //其实参数就是一个数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p>
<h3 id="实战：三大基本排序算法"><a href="#实战：三大基本排序算法" class="headerlink" title="实战：三大基本排序算法"></a><strong>实战：三大基本排序算法</strong></h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;8, 5, 0, 1, 4, 9, 2, 3, 6, 7&#125;;</span><br></pre></td></tr></table></figure>

<p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p>
<ul>
<li>冒泡排序</li>
</ul>
<p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p>
<ul>
<li>插入排序</li>
</ul>
<p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&amp;refer=http%3A%2F%2Fimg1.jjhgame.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632208529&amp;t=f3fb9be4dce91c6364f5ec4f9faafc94</a></p>
<ul>
<li>选择排序</li>
</ul>
<p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p>
<hr>
<h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a><strong>封装、继承和多态</strong></h2><p>封装、继承和多态是面向对象编程的三大特性。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p>
<p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setName(String name) &#123;</span><br><span class="line">    if(name.contains(&quot;小&quot;)) return;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p>
<p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p>
<p>封装就是通过访问权限控制来实现的。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p>
<p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SportsStudent extends Student&#123;   //通过extends关键字来继承父类</span><br><span class="line"></span><br><span class="line">    public SportsStudent(String name, int age) &#123;</span><br><span class="line">        super(name, age);   //必须先通过super关键字（指代父类），实现父类的构造方法！</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void exercise()&#123;</span><br><span class="line">        System.out.println(&quot;我超勇的！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArtStudent extends Student&#123;</span><br><span class="line"></span><br><span class="line">    public ArtStudent(String name, int age) &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void art()&#123;</span><br><span class="line">        System.out.println(&quot;随手画个毕加索！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p>
<p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p>
<p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Object obj = new Object;</span><br><span class="line">System.out.println(obj.hashCode());  //求对象的hashcode，默认是对象的内存地址</span><br><span class="line">System.out.println(obj.equals(obj));  //比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br><span class="line">System.out.println(obj.toString());  //将对象转换为字符串，默认生成对象的类名称+hashcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//父类中的study</span><br><span class="line">public void study()&#123;</span><br><span class="line">    System.out.println(&quot;学习&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类中的study</span><br><span class="line">@Override  //声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="line">public void study()&#123;</span><br><span class="line">    System.out.println(&quot;给你看点好康的&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     SportsStudent student = new SportsStudent(&quot;lbw&quot;, 20);</span><br><span class="line">     student.study();   //输出子类定义的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：静态方法能被重写吗？</p>
<p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void study()&#123;</span><br><span class="line">    super.study();</span><br><span class="line">    System.out.println(&quot;给你看点好康的&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setTest(int test)&#123;</span><br><span class="line">    test = 1;</span><br><span class="line">  	this.test = 1;</span><br><span class="line">  	super.test = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈类型转换"><a href="#再谈类型转换" class="headerlink" title="再谈类型转换"></a>再谈类型转换</h3><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = new SportsStudent(&quot;lbw&quot;, 20);  //父类变量引用子类实例</span><br><span class="line">student.study();     //得到依然是具体实现的结果，而不是当前类型的结果</span><br></pre></td></tr></table></figure>

<p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student student = new SportsStudent(&quot;lbw&quot;, 20);  //是由SportsStudent进行实现的</span><br><span class="line">//... do something...</span><br><span class="line"></span><br><span class="line">SportsStudent ps = (SportsStudent)student;  //让它变成一个具体的子类</span><br><span class="line">ps.sport();  //调用具体实现类的方法</span><br></pre></td></tr></table></figure>

<p>这样的类型转换称为向下转型。</p>
<h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void test(Student student)&#123;</span><br><span class="line">    if (student instanceof SportsStudent)&#123;</span><br><span class="line">        SportsStudent sportsStudent = (SportsStudent) student;</span><br><span class="line">        sportsStudent.sport();</span><br><span class="line">    &#125;else if (student instanceof ArtStudent)&#123;</span><br><span class="line">        ArtStudent artStudent = (ArtStudent) student;</span><br><span class="line">        artStudent.art();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p>
<p>思考：<code>student instanceof Student</code>的结果是什么？</p>
<h3 id="再谈final关键字"><a href="#再谈final关键字" class="headerlink" title="再谈final关键字"></a>再谈final关键字</h3><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Student &#123;   //类被声明为终态，那么它还能被继承吗</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void study()&#123;  //还能重写吗</span><br><span class="line">    System.out.println(&quot;学习&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final String name;   //引用类型不允许再指向其他对象</span><br><span class="line">private final int age;    //基本类型值不允许发生改变</span><br><span class="line"></span><br><span class="line">public Student(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Student &#123;    //抽象类</span><br><span class="line">		public abstract void test();  //抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p>
<p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student s = new Student()&#123;    //只能直接创建带实现的匿名内部类！</span><br><span class="line">  public void test()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void study()&#123;   //现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br><span class="line">    System.out.println(&quot;给你看点好康的&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Eat &#123;</span><br><span class="line">	void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Eat &#123;</span><br><span class="line">    default void eat()&#123;</span><br><span class="line">        //do something...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中定义的变量，默认为public static final</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Eat &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SportsStudent extends Student implements Eat, ...&#123;</span><br><span class="line">		@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p>
<p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h3><p>我们的类中可以在嵌套一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    class Inner&#123;   //类中定义的一个内部类</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test test = new Test();</span><br><span class="line">    Test.Inner inner = test.new Inner();   //写法有那么一丝怪异，但是没毛病！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static class Inner&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test.Inner inner = new Test.Inner();   //不用再创建外部类对象了！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><strong>局部内部类</strong></h3><p>对，你没猜错，就是和局部变量一样哒~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        class Inner&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Inner inner = new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Eat eat = new Eat() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void eat() &#123;</span><br><span class="line">                //DO something...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Eat eat = new Eat() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void eat() &#123;</span><br><span class="line">                //DO something...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Eat eat = () -&gt; &#123;&#125;;   //等价于上述内容</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p>
<p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a><strong>枚举类</strong></h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    private String status;</span><br><span class="line"></span><br><span class="line">  	//...</span><br><span class="line"></span><br><span class="line">  	public void setStatus(String status) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p>
<p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Status &#123;</span><br><span class="line">    RUNNING, STUDY, SLEEP    //直接写每个状态的名字即可，分号可以不打，但是推荐打上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举类也非常方便，我们只需要直接访问即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    private Status status;</span><br><span class="line"></span><br><span class="line"> 		//...</span><br><span class="line"></span><br><span class="line">  	public void setStatus(Status status) &#123;   //不再是String，而是我们指定的枚举类型</span><br><span class="line">        this.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Status getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Student student = new Student(&quot;小明&quot;, 18);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Compiled from &quot;Status.java&quot;</span><br><span class="line">public final class com.test.Status extends java.lang.Enum&lt;com.test.Status&gt; &#123;</span><br><span class="line">  public static final com.test.Status RUNNING;</span><br><span class="line">  public static final com.test.Status STUDY;</span><br><span class="line">  public static final com.test.Status SLEEP;</span><br><span class="line">  public static com.test.Status[] values();</span><br><span class="line">  public static com.test.Status valueOf(java.lang.String);</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Status &#123;</span><br><span class="line">    RUNNING(&quot;睡觉&quot;), STUDY(&quot;学习&quot;), SLEEP(&quot;睡觉&quot;);   //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><span class="line"></span><br><span class="line">    private final String name;    //枚举的成员变量</span><br><span class="line">    Status(String name)&#123;    //覆盖原有构造方法（默认private，只能内部使用！）</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	public String getName() &#123;   //获取封装的成员变量</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Student student = new Student(&quot;小明&quot;, 18);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类还自带一些继承下来的实用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status.valueOf(&quot;&quot;)   //将名称相同的字符串转换为枚举</span><br><span class="line">Status.values()   //快速获取所有的枚举</span><br></pre></td></tr></table></figure>

<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a><strong>基本类型包装类</strong></h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p>
<p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p>
<p><img src="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png" alt="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png"></p>
<ul>
<li>byte -&gt; Byte</li>
<li>boolean -&gt; Boolean</li>
<li>short -&gt; Short</li>
<li>char -&gt; Character</li>
<li>int -&gt; Integer</li>
<li>long -&gt; Long</li>
<li>float -&gt; Float</li>
<li>double -&gt; Double</li>
</ul>
<p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final int value;   //Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><span class="line"></span><br><span class="line">public Integer(int value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     Integer i = 1;   //包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br><span class="line">     System.out.println(i + i);    //包装类型可以直接被当做一个基本类型进行操作！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 1;    //其实这里只是简写了而已</span><br><span class="line">Integer i = Integer.valueOf(1);  //编译后真正的样子</span><br></pre></td></tr></table></figure>

<p>调用valueOf来生成一个Integer对象！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   //注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br><span class="line">       return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  	return new Integer(i);   //返回一个新创建好的对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i = Integer.valueOf(1);</span><br><span class="line">    int a = i;    //简写</span><br><span class="line">    int a = i.intValue();   //编译后实际的代码</span><br><span class="line"></span><br><span class="line">  	long c = i.longValue();   //其他类型也有！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i1 = 28914;</span><br><span class="line">    Integer i2 = 28914;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);   //实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br><span class="line">    System.out.println(i1.equals(i2));   //这个才是真正的值判断！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意IntegerCache带来的影响！</p>
<p>思考：下面这种情况结果会是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i1 = 28914;</span><br><span class="line">    Integer i2 = 28914;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1+1 == i2+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在集合类的学习中，我们还会继续用到我们的包装类型！</p>
<hr>
<h2 id="面向对象编程实战"><a href="#面向对象编程实战" class="headerlink" title="面向对象编程实战"></a><strong>面向对象编程实战</strong></h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 1; i &lt;= 100; i++) &#123;   //for循环暴力求解，简单，但是效率似乎低了一些</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println((1 + 100) * 50);  //高斯求和公式，利用数学，瞬间计算结果！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p>
<h3 id="对象设计（面向对象、多态运用）"><a href="#对象设计（面向对象、多态运用）" class="headerlink" title="对象设计（面向对象、多态运用）"></a><strong>对象设计（面向对象、多态运用）</strong></h3><ul>
<li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li>
<li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li>
<li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li>
</ul>
<h3 id="二分搜索（搜索算法）"><a href="#二分搜索（搜索算法）" class="headerlink" title="二分搜索（搜索算法）"></a><strong>二分搜索（搜索算法）</strong></h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26&#125;;   //测试用例</span><br><span class="line"></span><br><span class="line">private static int test(int[] arr, int target)&#123;</span><br><span class="line">    //请在这里实现搜索算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序（排序算法、递归分治）"><a href="#快速排序（排序算法、递归分治）" class="headerlink" title="快速排序（排序算法、递归分治）"></a><strong>快速排序（排序算法、递归分治）</strong></h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p>
<p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p>
<h3 id="0-1背包问题（回溯法、剪枝-动态规划优化）"><a href="#0-1背包问题（回溯法、剪枝-动态规划优化）" class="headerlink" title="0/1背包问题（回溯法、剪枝/动态规划优化）"></a><strong>0/1背包问题（回溯法、剪枝/动态规划优化）</strong></h3><p>给定 <code>n</code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] w = &#123;2, 3, 4, 5&#125;;</span><br><span class="line">int[] v = &#123;3, 4, 5, 6&#125;;</span><br><span class="line">int capacity = 8;</span><br></pre></td></tr></table></figure>

<h1 id="Java异常机制"><a href="#Java异常机制" class="headerlink" title="Java异常机制"></a>Java异常机制</h1><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    test(1, 0);   //当b为0的时候，还能正常运行吗？</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int test(int a, int b)&#123;</span><br><span class="line">    return a/b;   //没有任何的判断而是直接做计算</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.test.Application.test(Application.java:9)</span><br><span class="line">    at com.test.Application.main(Application.java:5)</span><br></pre></td></tr></table></figure>

<p>当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h2><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a><strong>运行时异常</strong></h3><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自<code>RuntimeException</code>。</p>
<h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a><strong>编译时异常</strong></h3><p>异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;my.txt&quot;);</span><br><span class="line">file.createNewFile();   //要调用此方法，首先需要处理异常</span><br></pre></td></tr></table></figure>

<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a><strong>错误</strong></h2><p>错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[Integer.MAX_VALUE];   //能创建如此之大的数组吗？</span><br></pre></td></tr></table></figure>

<p>运行后得到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at com.test.Main.main(Main.java:14)</span><br></pre></td></tr></table></figure>

<p>错误都继承自<code>Error</code>类，一般情况下，程序中只能处理异常，错误是很难进行处理的，<code>Error</code>和<code>Execption</code>都继承自<code>Throwable</code>类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[Integer.MAX_VALUE];</span><br><span class="line">System.out.println(&quot;lbwnb&quot;);  //还能正常打印吗？</span><br></pre></td></tr></table></figure>

<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a><strong>异常的处理</strong></h2><p>当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[5];</span><br><span class="line">arr[5] = 1;  //我们需要处理这种情况，保证后面的代码正常运行！</span><br><span class="line">System.out.println(&quot;lbwnb&quot;);</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>try</code>和<code>catch</code>语句块来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[5];</span><br><span class="line">try&#123;    //在try块中运行代码</span><br><span class="line">     arr[5] = 1;    //当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象</span><br><span class="line">&#125;catch (ArrayIndexOutOfBoundsException e)&#123;   //捕获的异常类型</span><br><span class="line">     System.out.println(&quot;程序运行出现异常！&quot;);  //出现异常时执行</span><br><span class="line">&#125;</span><br><span class="line">//后面的代码会正常运行</span><br><span class="line">System.out.println(&quot;lbwnb&quot;);</span><br></pre></td></tr></table></figure>

<p>当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。</p>
<p>我们可以通过使用<code>e.printStackTrace()</code>来打印栈追踪信息，定位我们的异常出现位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArrayIndexOutOfBoundsException: 5</span><br><span class="line">    at com.test.Main.main(Main.java:7)    //Main类的第7行出现问题</span><br><span class="line">程序运行出现异常！</span><br><span class="line">lbwnb</span><br></pre></td></tr></table></figure>

<p>运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;my.txt&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">  file.createNewFile();</span><br><span class="line">&#125; catch (IOException e) &#123;  //捕获声明的异常类型</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以捕获到类型不止是<code>Exception</code>的子类，只要是继承自<code>Throwalbe</code>的类，都能被捕获，也就是说，<code>Error</code>也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现<code>Error</code>应该从问题的根源去解决。</p>
<h2 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a><strong>异常的抛出</strong></h2><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test(1, 0);</span><br><span class="line">        &#125; catch (Exception e) &#123;   //捕获方法中会出现的异常</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int test(int a, int b) throws Exception &#123;  //声明抛出的异常类型</span><br><span class="line">        if(b == 0) throw new Exception(&quot;0不能做除数！&quot;);  //创建异常对象并抛出异常</span><br><span class="line">        return a/b;  //抛出异常会终止代码运行</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>throw</code>关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。</p>
<p>如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息）</p>
<p>如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明<code>throws</code>来继续交给上一级处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;  //出现异常就再往上抛，而不是在此方法内处理</span><br><span class="line">  test(1, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int test(int a, int b) throws Exception &#123;  //声明抛出的异常类型</span><br><span class="line">  if(b == 0) throw new Exception(&quot;0不能做除数！&quot;);  //创建异常对象并抛出异常</span><br><span class="line">  return a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息）</p>
<p>异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            test(1, 0);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;外层&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int test(int a, int b)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            if(b == 0) throw new Exception(&quot;0不能做除数！&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;内层&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return a/b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><strong>自定义异常</strong></h2><p>JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;  //直接继承即可</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws MyException &#123;</span><br><span class="line">        throw new MyException();   //直接使用</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用父类的带描述的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line"></span><br><span class="line">    public MyException(String message)&#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws MyException &#123;</span><br><span class="line">    throw new MyException(&quot;出现了自定义的错误&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获异常指定的类型，会捕获其所有子异常类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw new MyException(&quot;出现了自定义的错误&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;    //捕获父异常类型</span><br><span class="line">  System.out.println(&quot;捕获到异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重异常捕获和finally关键字"><a href="#多重异常捕获和finally关键字" class="headerlink" title="多重异常捕获和finally关键字"></a><strong>多重异常捕获和finally关键字</strong></h2><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //....</span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; catch (IndexOutOfBoundsException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; catch (RuntimeException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，类似于<code>if-else if</code>的结构，父异常类型只能放在最后！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //....</span><br><span class="line">&#125; catch (RuntimeException e)&#123;  //父类型在前，会将子类的也捕获</span><br><span class="line"></span><br><span class="line">&#125; catch (NullPointerException e) &#123;   //永远都不会被捕获</span><br><span class="line"></span><br><span class="line">&#125; catch (IndexOutOfBoundsException e)&#123;   //永远都不会被捕获</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望把这些异常放在一起进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">     //....</span><br><span class="line">&#125; catch (NullPointerException | IndexOutOfBoundsException e) &#123;  //用|隔开每种类型即可</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给<code>finally</code>语句块来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //....</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;finally &#123;</span><br><span class="line">  System.out.println(&quot;lbwnb&quot;);   //无论是否出现异常，都会在最后执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    a /= 0;</span><br><span class="line">&#125;finally &#123;  //不捕获异常，程序会终止，但在最后依然会执行下面的内容</span><br><span class="line">    System.out.println(&quot;lbwnb&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：<code>try</code>、<code>catch</code>和<code>finally</code>执行顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static int test(int a)&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;catch (Exception e)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;finally &#123;</span><br><span class="line">    a =  a + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Java泛型与集合类"><a href="#Java泛型与集合类" class="headerlink" title="Java泛型与集合类"></a>Java泛型与集合类</h1><p>在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。</p>
<h2 id="走进泛型"><a href="#走进泛型" class="headerlink" title="走进泛型"></a><strong>走进泛型</strong></h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Score &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    Object score;  //因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span><br><span class="line"></span><br><span class="line">    public Score(String name, String id, Object score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Score score = new Score(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);  //是String类型的</span><br><span class="line"></span><br><span class="line">    //....</span><br><span class="line"></span><br><span class="line">    Integer number = (Integer) score.score;  //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行时出现异常！</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br><span class="line">    at com.test.Main.main(Main.java:14)</span><br></pre></td></tr></table></figure>

<p>使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法）</p>
<p>为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Score&lt;T&gt; &#123;   //将Score转变为泛型类&lt;T&gt;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;  //T为泛型，根据用户提供的类型自动变成对应类型</span><br><span class="line"></span><br><span class="line">    public Score(String name, String id, T score) &#123;   //提供的score类型即为T代表的类型</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //直接确定Score的类型是字符串类型的成绩</span><br><span class="line">    Score&lt;String&gt; score = new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);</span><br><span class="line"></span><br><span class="line">    Integer i = score.score;  //编译不通过，因为成员变量score类型被定为String！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！</p>
<p>泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//反编译后的代码</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Score score = new Score(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);</span><br><span class="line">        String i = (String)score.score;   //其实依然会变为强制类型转换，但是这是由编译器帮我们完成的</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>像这样在编译后泛型的内容消失转变为Object的情况称为<code>类型擦除</code>（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。</p>
<p>综上，泛型其实就是一种类型参数，用于指定类型。</p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a><strong>泛型的使用</strong></h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h3><p>上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是<code>类型</code>的英文单词首字母，当然也可以添加数字和其他的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Score&lt;T&gt; &#123;   //将Score转变为泛型类&lt;T&gt;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;  //T为泛型，根据用户提供的类型自动变成对应类型</span><br><span class="line"></span><br><span class="line">    public Score(String name, String id, T score) &#123;   //提供的score类型即为T代表的类型</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个普通类型中定义泛型，泛型T称为<code>参数化类型</code>，在定义泛型类的引用时，需要明确指出类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score = new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);</span><br></pre></td></tr></table></figure>

<p>此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = score.score;   //编译不通过，因为成员变量score明确为String类型</span><br></pre></td></tr></table></figure>

<p>注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static T score;   //错误，不能在静态成员上定义</span><br></pre></td></tr></table></figure>

<p>由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。</p>
<p>泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;double&gt; score = new Score&lt;double&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 90.5);  //编译不通过</span><br></pre></td></tr></table></figure>

<p>那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。</p>
<h3 id="类的泛型方法"><a href="#类的泛型方法" class="headerlink" title="类的泛型方法"></a><strong>类的泛型方法</strong></h3><p>泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public T getScore() &#123;    //若方法的返回值类型为泛型，那么编译器会自动进行推断</span><br><span class="line">  return score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setScore(T score) &#123;   //若方法的形式参数为泛型，那么实参只能是定义时的类型</span><br><span class="line">  this.score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score = new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);</span><br><span class="line">score.setScore(10);   //编译不通过，因为只接受String类型</span><br></pre></td></tr></table></figure>

<p>同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型）</p>
<h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a><strong>自定义泛型方法</strong></h3><p>那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void test(E e)&#123;   //在方法定义前声明泛型</span><br><span class="line">  System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; void test(E e)&#123;</span><br><span class="line">  System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。</p>
<p>注意一定要区分类定义的泛型和方法前定义的泛型！</p>
<h3 id="泛型引用"><a href="#泛型引用" class="headerlink" title="泛型引用"></a><strong>泛型引用</strong></h3><p>可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;Integer&gt; score;  //声明泛型为Integer类型</span><br></pre></td></tr></table></figure>

<p>如果不希望指定类型，或是希望此引用类型可以引用任意泛型的<code>Score</code>类对象，可以使用<code>?</code>通配符，来表示自动匹配任意的可用类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;?&gt; score;   //score可以引用任意的Score类型对象了！</span><br></pre></td></tr></table></figure>

<p>那么使用通配符之后，得到的泛型成员变量会是什么类型呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = score.getScore();   //只能变为Object</span><br></pre></td></tr></table></figure>

<p>因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。</p>
<p>在学习了泛型的界限后，我们还会继续了解通配符的使用。</p>
<h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a><strong>泛型的界限</strong></h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Score&lt;T extends Number&gt; &#123;   //设定泛型上界，必须是Number的子类</span><br><span class="line">    private final String name;</span><br><span class="line">    private final String id;</span><br><span class="line">    private T score;</span><br><span class="line"></span><br><span class="line">    public Score(String name, String id, T score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>extends</code>关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。</p>
<p>同样的，泛型通配符也支持泛型的界限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;? extends Number&gt; score;  //限定为匹配Number及其子类的类型</span><br></pre></td></tr></table></figure>

<p>同理，既然泛型有上限，那么也有下限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;? super Integer&gt; score;   //限定为匹配Integer及其父类</span><br></pre></td></tr></table></figure>

<p>通过<code>super</code>关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。</p>
<p>图解如下：</p>
<p><img src="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523263309.png" alt="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523263309.png"></p>
<p><img src="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523264595.jpg" alt="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523264595.jpg"></p>
<p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;? extends Number&gt; score = new Score&lt;&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);</span><br><span class="line">Number o = score.getScore();    //得到的结果为上界类型</span><br></pre></td></tr></table></figure>

<p>也就是说，一旦我们指定了上界后，编译器就将范围从原始类型<code>Object</code>提升到我们指定的上界<code>Number</code>，但是依然无法明确具体类型。思考：那如果定义下限呢？</p>
<p>那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//使用javap -l 进行反编译</span><br><span class="line">public class com.test.Score&lt;T extends java.lang.Number&gt; &#123;</span><br><span class="line">  public com.test.Score(java.lang.String, java.lang.String, T);</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 8: 0</span><br><span class="line">      line 9: 4</span><br><span class="line">      line 10: 9</span><br><span class="line">      line 11: 14</span><br><span class="line">      line 12: 19</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      20     0  this   Lcom/test/Score;</span><br><span class="line">          0      20     1  name   Ljava/lang/String;</span><br><span class="line">          0      20     2    id   Ljava/lang/String;</span><br><span class="line">          0      20     3 score   Ljava/lang/Number;   //可以看到score的类型直接被编译为Number类</span><br><span class="line"></span><br><span class="line">  public T getScore();</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 15: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       5     0  this   Lcom/test/Score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，一旦确立上限后，编译器会自动将类型提升到上限类型。</p>
<h3 id="钻石运算符"><a href="#钻石运算符" class="headerlink" title="钻石运算符"></a><strong>钻石运算符</strong></h3><p>我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;Integer&gt; score = new Score&lt;Integer&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);  //1.7之前</span><br><span class="line"></span><br><span class="line">Score&lt;Integer&gt; score = new Score&lt;&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);  //1.7之后</span><br></pre></td></tr></table></figure>

<h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a><strong>泛型与多态</strong></h3><p>泛型不仅仅可以可以定义在类上，同时也能定义在接口上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ScoreInterface&lt;T&gt; &#123;</span><br><span class="line">    T getScore();</span><br><span class="line">    void setScore(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Score&lt;T&gt; implements ScoreInterface&lt;T&gt;&#123;   //将Score转变为泛型类&lt;T&gt;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final String id;</span><br><span class="line">    private T score;</span><br><span class="line"></span><br><span class="line">    public Score(String name, String id, T score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setScore(T score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StringScore implements ScoreInterface&lt;String&gt;&#123;   //在实现时明确类型</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getScore() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setScore(String s) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类同理，这里就不多做演示了。</p>
<h3 id="多态类型擦除"><a href="#多态类型擦除" class="headerlink" title="多态类型擦除"></a><strong>多态类型擦除</strong></h3><p>思考一个问题，既然继承后明确了泛型类型，那么为什么<code>@Override</code>不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A&lt;T&gt;&#123;</span><br><span class="line">    private T t;</span><br><span class="line">    public T get()&#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void set(T t)&#123;</span><br><span class="line">        this.t=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&lt;Number&gt;&#123;</span><br><span class="line">    private Number n;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Number get()&#123;   //这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(Number t)&#123;</span><br><span class="line">        this.t=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object get()&#123;</span><br><span class="line">  return this.get();//调用返回Number的那个方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void set(Object t )&#123;</span><br><span class="line">  this.set((Number)t ); //调用参数是Number的那个方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a><strong>数据结构基础</strong></h2><p>警告！本章最难的部分！</p>
<p>学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。</p>
<p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p>
<p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><strong>线性表</strong></h3><p>线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>将数据依次存储在连续的整块物理空间中，这种存储结构称为<code>顺序存储结构</code>，而以这种方式实现的线性表，我们称为<code>顺序表</code>。</p>
<p>同样的，表中的每一个个体都被称为<code>元素</code>，元素左边的元素（上一个元素），称为<code>前驱</code>，同理，右边的元素（后一个元素）称为<code>后驱</code>。</p>
<p>我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。</p>
<p>目标：以数组为底层，编写以下抽象类的具体实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线性表抽象类</span><br><span class="line"> * @param &lt;E&gt; 存储的元素(Element)类型</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractList&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取表的长度</span><br><span class="line">     * @return 顺序表的长度</span><br><span class="line">     */</span><br><span class="line">    public abstract int size();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加一个元素</span><br><span class="line">     * @param e 元素</span><br><span class="line">     * @param index 要添加的位置(索引)</span><br><span class="line">     */</span><br><span class="line">    public abstract void add(E e, int index);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除指定位置的元素</span><br><span class="line">     * @param index 位置</span><br><span class="line">     * @return 移除的元素</span><br><span class="line">     */</span><br><span class="line">    public abstract E remove(int index);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定位置的元素</span><br><span class="line">     * @param index 位置</span><br><span class="line">     * @return 元素</span><br><span class="line">     */</span><br><span class="line">    public abstract E get(int index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为<code>链式存储结构</code></p>
<p>实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象）</p>
<p>利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！</p>
<p>比较：顺序表和链表的优异？</p>
<p>顺序表优缺点：</p>
<ul>
<li>访问速度快，随机访问性能高</li>
<li>插入和删除的效率低下，极端情况下需要变更整个表</li>
<li>不易扩充，需要复制并重新创建数组</li>
</ul>
<p>链表优缺点：</p>
<ul>
<li>插入和删除效率高，只需要改变连接点的指向即可</li>
<li>动态扩充容量，无需担心容量问题</li>
<li>访问元素需要依次寻找，随机访问元素效率低下</li>
</ul>
<p>链表只能指向后面，能不能指向前面呢？双向链表！</p>
<hr>
<p>栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。</p>
<p>向栈中插入一个元素时，称为<code>入栈（压栈）</code>，移除栈顶元素称为<code>出栈</code>，我们需要尝试实现以下抽象类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象类型栈，待实现</span><br><span class="line"> * @param &lt;E&gt; 元素类型</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractStack&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出栈操作</span><br><span class="line">     * @return 栈顶元素</span><br><span class="line">     */</span><br><span class="line">    public abstract E pop();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入栈操作</span><br><span class="line">     * @param e 元素</span><br><span class="line">     */</span><br><span class="line">    public abstract void push(E e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，我们的JVM在处理方法调用时，也是一个栈操作：</p>
<p>所以说，如果玩不好递归，就会像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void go()&#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">	at com.test.Main.go(Main.java:13)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>栈的深度是有限制的，如果达到限制，将会出现<code>StackOverflowError</code>错误（注意是错误！说明是JVM出现了问题）</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。</p>
<p>所以我们要实现以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;E&gt;</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractQueue&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进队操作</span><br><span class="line">     * @param e 元素</span><br><span class="line">     */</span><br><span class="line">    public abstract void offer(E e);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出队操作</span><br><span class="line">     * @return 元素</span><br><span class="line">     */</span><br><span class="line">    public abstract E poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h3><p>本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。</p>
<p>一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为<code>根结点</code>，而结点拥有的子节点数量称为<code>度</code>，每向下一级称为一个<code>层次</code>，树中出现的最大层次称为树的<code>深度(高度)</code>。</p>
<h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右）</p>
<p>数学性质：</p>
<ul>
<li>在二叉树的第i层上最多有2^(i-1) 个节点。</li>
<li>二叉树中如果深度为k，那么最多有2^k-1个节点。</li>
</ul>
<p>设计一个二叉树结点类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    public E e;   //当前结点数据</span><br><span class="line">    public TreeNode&lt;E&gt; left;   //左子树</span><br><span class="line">    public TreeNode&lt;E&gt; right;   //右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式：</p>
<ul>
<li><strong>前序遍历</strong>：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF</li>
<li><strong>中序遍历</strong>：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF</li>
<li><strong>后序遍历</strong>：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA</li>
</ul>
<h3 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h3><p>满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.examw.com%2Fncre%2FFiles%2F2011-6%2F20%2F93236613.gif&refer=http%3A%2F%2Fwww.examw.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634373420&t=19f3ed8195b15d0b8f49201cc2803759">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.examw.com%2Fncre%2FFiles%2F2011-6%2F20%2F93236613.gif&amp;refer=http%3A%2F%2Fwww.examw.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634373420&amp;t=19f3ed8195b15d0b8f49201cc2803759</a></p>
<p>其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。</p>
<h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a><strong>快速查找</strong></h3><p>我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！</p>
<p>不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做<code>hashcode()</code>的方法？而这个方法呢，就是为了更好地支持哈希表的实现。<code>hashcode()</code>默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。</p>
<p>哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样：</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2127470%2F202012%2F2127470-20201222194727385-1606433879.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634376519&t=8cc6fc7a35e695cc5ba12687974daa54">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2127470%2F202012%2F2127470-20201222194727385-1606433879.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634376519&amp;t=8cc6fc7a35e695cc5ba12687974daa54</a></p>
<p>数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//假设hash表长度为16，hash算法为：</span><br><span class="line">private int hash(int hashcode)&#123;</span><br><span class="line">  return hashcode % 16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为<code>hash碰撞</code>，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。</p>
<p>当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲）</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样：</p>
<p>不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为<code>二叉排序树</code>。利用二分搜索的思想，我们就可以快速查找某个节点！</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样：</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20191127151205330.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE5MTA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634378465&t=eb9bf93cfb9191362d1170b93b06d902">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20191127151205330.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE5MTA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634378465&amp;t=eb9bf93cfb9191362d1170b93b06d902</a></p>
<p>显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。</p>
<p>现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为<code>平衡二叉树</code>，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况：</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png" alt="https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png"></p>
<p>左左失衡</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png" alt="https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png"></p>
<p>右右失衡</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png" alt="https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png"></p>
<p>左右失衡</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png" alt="https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png"></p>
<p>右左失衡</p>
<p>通过以上四种情况的处理，最终得到维护平衡二叉树的算法。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1301290%2F201904%2F1301290-20190418213139526-1239863354.jpg&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634381313&t=d60b654d81ee3930b8518f194c976409">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1301290%2F201904%2F1301290-20190418213139526-1239863354.jpg&amp;refer=http%3A%2F%2Fimg2018.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634381313&amp;t=d60b654d81ee3930b8518f194c976409</a></p>
<p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>我们来看看一个节点，是如何插入到红黑树中的：</p>
<p>基本的 插入规则和平衡二叉树一样，但是在插入后：</p>
<ol>
<li>将新插入的节点标记为红色</li>
<li>如果 X 是根结点(root)，则标记为黑色</li>
<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>
</ol>
<ul>
<li>3.1 如果 X 的 uncle (叔叔) 是红色</li>
<li>3.1.1 将 parent 和 uncle 标记为黑色3.1.2 将 grand parent (祖父) 标记为红色3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li>
<li>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</li>
<li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子)3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子)其实这种情况下处理就和我们的平衡二叉树一样了</li>
</ul>
<hr>
<h2 id="认识集合类"><a href="#认识集合类" class="headerlink" title="认识集合类"></a><strong>认识集合类</strong></h2><p>集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。</p>
<p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。</p>
<p>集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.mianfeiwendang.com%2Fpic%2F29a5b61e9e5e19fe10103b4c%2F1-356-jpg_6_0_______-858-0-0-858.jpg&refer=http%3A%2F%2Fwww.mianfeiwendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634434848&t=e696ab71af584ef08a38fc328956586c">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.mianfeiwendang.com%2Fpic%2F29a5b61e9e5e19fe10103b4c%2F1-356-jpg_6_0_______-858-0-0-858.jpg&amp;refer=http%3A%2F%2Fwww.mianfeiwendang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634434848&amp;t=e696ab71af584ef08a38fc328956586c</a></p>
<h3 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a><strong>数组与集合</strong></h3><p>相同之处：</p>
<ol>
<li>它们都是容器，都能够容纳一组元素。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>数组的大小是固定的，集合的大小是可变的。</li>
<li>数组可以存放基本数据类型，但集合只能存放对象。</li>
<li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li>
</ol>
<h3 id="集合根接口Collection"><a href="#集合根接口Collection" class="headerlink" title="集合根接口Collection"></a><strong>集合根接口Collection</strong></h3><p>本接口中定义了全部的集合基本操作，我们可以在源码中看看。</p>
<p>我们再来看看List和Set以及Queue接口。</p>
<h2 id="集合类的使用"><a href="#集合类的使用" class="headerlink" title="集合类的使用"></a><strong>集合类的使用</strong></h2><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a><strong>List列表</strong></h3><p>首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。</p>
<p>先看看ArrayList的源码！</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();  //默认长度的列表</span><br><span class="line">List&lt;String&gt; listInit = new ArrayList&lt;&gt;(100);  //初始长度为100的列表</span><br></pre></td></tr></table></figure>

<p>向列表中添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;lbwnb&quot;);</span><br><span class="line">list.add(&quot;yyds&quot;);</span><br><span class="line">list.contains(&quot;yyds&quot;); //是否包含某个元素</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>移除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(&quot;lbwnb&quot;);</span><br><span class="line">    list.add(&quot;yyds&quot;);</span><br><span class="line">    list.remove(0);   //按下标移除元素</span><br><span class="line">    list.remove(&quot;yyds&quot;);    //移除指定元素</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也支持批量操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.addAll(new ArrayList&lt;&gt;());   //在尾部批量添加元素</span><br><span class="line">    list.removeAll(new ArrayList&lt;&gt;());   //批量移除元素（只有给定集合中存在的元素才会被移除）</span><br><span class="line">    list.retainAll(new ArrayList&lt;&gt;());   //只保留某些元素</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。</p>
<p>其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">    list.offer(&quot;A&quot;);   //入队</span><br><span class="line">    System.out.println(list.poll());  //出队</span><br><span class="line">    list.push(&quot;A&quot;);</span><br><span class="line">    list.push(&quot;B&quot;);    //进栈</span><br><span class="line">    list.push(&quot;C&quot;);</span><br><span class="line">    System.out.println(list.pop());</span><br><span class="line">    System.out.println(list.pop());    //出栈</span><br><span class="line">    System.out.println(list.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用代码块来快速添加内容"><a href="#利用代码块来快速添加内容" class="headerlink" title="利用代码块来快速添加内容"></a>利用代码块来快速添加内容</h3><p>前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new LinkedList&lt;String&gt;()&#123;&#123;    //初始化时添加</span><br><span class="line">  this.add(&quot;A&quot;);</span><br><span class="line">  this.add(&quot;B&quot;);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。</p>
<h3 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;()&#123;   //Java9才支持匿名内部类使用钻石运算符</span><br><span class="line">    &#123;</span><br><span class="line">        this.add(10);</span><br><span class="line">        this.add(2);</span><br><span class="line">        this.add(5);</span><br><span class="line">        this.add(8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">list.sort((a, b) -&gt; &#123;    //排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现</span><br><span class="line">  return a - b;    //返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h3><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>所有的集合类，都支持foreach循环！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;()&#123;   //Java9才支持匿名内部类使用钻石运算符</span><br><span class="line">        &#123;</span><br><span class="line">            this.add(10);</span><br><span class="line">            this.add(2);</span><br><span class="line">            this.add(5);</span><br><span class="line">            this.add(8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    for (Integer integer : list) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(i -&gt; &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.replaceAll((i) -&gt; &#123;</span><br><span class="line">  if(i == 2) return 3;   //将所有的2替换为3</span><br><span class="line">  else return i;   //不是2就不变</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h3 id="Iterable和Iterator接口"><a href="#Iterable和Iterator接口" class="headerlink" title="Iterable和Iterator接口"></a>Iterable和Iterator接口</h3><p>我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。</p>
<p>由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。</p>
<p>我们先来看看迭代器里面方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个集合类都有自己的迭代器，通过<code>iterator()</code>方法来获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();   //生成一个新的迭代器</span><br><span class="line">while (iterator.hasNext())&#123;    //判断是否还有下一个元素</span><br><span class="line">  Integer i = iterator.next();     //获取下一个元素（获取一个少一个）</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器生成后，默认指向第一个元素，每次调用<code>next()</code>方法，都会将指针后移，当指针移动到最后一个元素之后，调用<code>hasNext()</code>将会返回<code>false</code>，迭代器是一次性的，用完即止，如果需要再次使用，需要调用<code>iterator()</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;Integer&gt; iterator = list.listIterator();   //List还有一个更好地迭代器实现ListIterator</span><br></pre></td></tr></table></figure>

<p><code>ListIterator</code>是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。</p>
<hr>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h3><p>我们之前已经看过<code>Set</code>接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。</p>
<p>Set集合特点：</p>
<ul>
<li>不允许出现重复元素</li>
<li>不支持随机访问（不允许通过下标访问）</li>
</ul>
<p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    set.add(120);    //支持插入元素，但是不支持指定位置插入</span><br><span class="line">    set.add(13);</span><br><span class="line">    set.add(11);</span><br><span class="line">    for (Integer integer : set) &#123;</span><br><span class="line">      System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用<code>哈希表</code>来实现的，实际的存放顺序是由Hash算法决定的。</p>
<p>那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();  //会自动保存我们的插入顺序</span><br><span class="line">    set.add(120);</span><br><span class="line">    set.add(13);</span><br><span class="line">    set.add(11);</span><br><span class="line">    for (Integer integer : set) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p>
<p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">    set.add(1);</span><br><span class="line">    set.add(3);</span><br><span class="line">    set.add(2);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;((a, b) -&gt; b - a);   //在创建对象时指定规则即可</span><br><span class="line">    set.add(1);</span><br><span class="line">    set.add(3);</span><br><span class="line">    set.add(2);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的结果就是我们自定义的排序规则了。</p>
<p>虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p>
<hr>
<h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a><strong>Map映射</strong></h3><h3 id="什么是映射"><a href="#什么是映射" class="headerlink" title="什么是映射"></a>什么是映射</h3><p>我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p>
<p><a target="_blank" rel="noopener" href="https://bkimg.cdn.bcebos.com/pic/7aec54e736d12f2e89cbcbb64dc2d5628435681d?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg">https://bkimg.cdn.bcebos.com/pic/7aec54e736d12f2e89cbcbb64dc2d5628435681d?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg</a></p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。</p>
<p>我们先来看看Map接口中定义了哪些操作。</p>
<h3 id="HashMap和LinkedHashMap"><a href="#HashMap和LinkedHashMap" class="headerlink" title="HashMap和LinkedHashMap"></a>HashMap和LinkedHashMap</h3><p>HashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16566539-672ab962ae6dc500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="https://upload-images.jianshu.io/upload_images/16566539-672ab962ae6dc500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp"></p>
<p>哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。</p>
<p>而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, initialized on first use, and resized as</span><br><span class="line"> * necessary. When allocated, length is always a power of two.</span><br><span class="line"> * (We also tolerate length zero in some operations to allow</span><br><span class="line"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial capacity - MUST be a power of two.</span><br><span class="line"> */</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>

<p>我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。</p>
<p>我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The load factor for the hash table.</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>

<p>我们还发现HashMap源码中有这样一个变量，也就是<code>负载因子</code>，那么它是干嘛的呢？</p>
<p>负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是<code>0.75</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>

<p>那么负载因子是怎么控制扩容的呢？<code>0.75</code>的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。</p>
<p>但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。</p>
<p><img src="https://i0.hdslb.com/bfs/album/5884577601a5ab1aabe10ee95696557b8d3b5338.jpg" alt="https://i0.hdslb.com/bfs/album/5884577601a5ab1aabe10ee95696557b8d3b5338.jpg"></p>
<p>当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span><br><span class="line"> * extends Node) so can be used as extension of either regular or</span><br><span class="line"> * linked node.</span><br><span class="line"> */</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * HashMap.Node subclass for normal LinkedHashMap entries.</span><br><span class="line"> */</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    LinkedHashMap&lt;Integer, String&gt; map = new LinkedHashMap&lt;&gt;(16, 0.75f, true);  //以访问顺序</span><br><span class="line">    map.put(1, &quot;A&quot;);</span><br><span class="line">    map.put(2, &quot;B&quot;);</span><br><span class="line">    map.put(3, &quot;C&quot;);</span><br><span class="line">    map.get(2);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果，我们发现，刚访问的结果被排到了最后一位。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The comparator used to maintain order in this tree map, or</span><br><span class="line"> * null if it uses the natural ordering of its keys.</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private final Comparator&lt;? super K&gt; comparator;</span><br><span class="line"></span><br><span class="line">private transient Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Node in the Tree.  Doubles as a means to pass key-value pairs back to</span><br><span class="line">* user (see Map.Entry).</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。</p>
<h3 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h3><p>我们首先来看看Map的一些基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1, &quot;A&quot;);</span><br><span class="line">    map.put(2, &quot;B&quot;);</span><br><span class="line">    map.put(3, &quot;C&quot;);</span><br><span class="line">    System.out.println(map.get(1));    //获取Key为1的值</span><br><span class="line">    System.out.println(map.getOrDefault(0, &quot;K&quot;));  //不存在就返回K</span><br><span class="line">   	map.remove(1);   //移除这个Key的键值对</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1, &quot;A&quot;);</span><br><span class="line">    map.put(2, &quot;B&quot;);</span><br><span class="line">    map.put(3, &quot;C&quot;);</span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v));</span><br><span class="line"></span><br><span class="line">  	for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;   //也可以获取所有的Entry来foreach</span><br><span class="line">      int key = entry.getKey();</span><br><span class="line">      String value = entry.getValue();</span><br><span class="line">      System.out.println(key+&quot; -&gt; &quot;+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以单独获取所有的值或者是键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1, &quot;A&quot;);</span><br><span class="line">    map.put(2, &quot;B&quot;);</span><br><span class="line">    map.put(3, &quot;C&quot;);</span><br><span class="line">    System.out.println(map.keySet());   //直接获取所有的key</span><br><span class="line">    System.out.println(map.values());   //直接获取所有的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈Set原理"><a href="#再谈Set原理" class="headerlink" title="再谈Set原理"></a>再谈Set原理</h3><p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Dummy value to associate with an Object in the backing Map</span><br><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure>

<p>我们发现，在添加元素时，其实添加的是一个键为我们插入的元素，而值就是<code>PRESENT</code>常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Adds the specified element to this set if it is not already present.</span><br><span class="line"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="line"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="line"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="line"> * If this set already contains the element, the call leaves the set</span><br><span class="line"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be added to this set</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="line"> * element</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察其他的方法，也几乎都是在用HashMap做事，所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p>
<p>再来看TreeSet，实际上用的就是我们的TreeMap：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The backing map.</span><br><span class="line"> */</span><br><span class="line">private transient NavigableMap&lt;E,Object&gt; m;</span><br></pre></td></tr></table></figure>

<p>同理，这里就不多做阐述了。</p>
<h3 id="JDK1-8新增方法使用"><a href="#JDK1-8新增方法使用" class="headerlink" title="JDK1.8新增方法使用"></a>JDK1.8新增方法使用</h3><p>最后，我们再来看看JDK1.8中集合类新增的一些操作（之前没有提及的）首先来看看<code>compute</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1, &quot;A&quot;);</span><br><span class="line">    map.put(2, &quot;B&quot;);</span><br><span class="line">    map.compute(1, (k, v) -&gt; &#123;   //compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span><br><span class="line">        return v+&quot;M&quot;;     //这里返回原来的value+M</span><br><span class="line">    &#125;);</span><br><span class="line">  	map.computeIfPresent(1, (k, v) -&gt; &#123;   //当Key存在时存在则计算并赋予新的值</span><br><span class="line">      return v+&quot;M&quot;;     //这里返回原来的value+M</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1, &quot;A&quot;);</span><br><span class="line">    map.put(2, &quot;B&quot;);</span><br><span class="line">    map.computeIfAbsent(0, (k) -&gt; &#123;   //若不存在则计算并插入新的值</span><br><span class="line">        return &quot;M&quot;;     //这里返回M</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge方法用于处理数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Student&gt; students = Arrays.asList(</span><br><span class="line">            new Student(&quot;yoni&quot;, &quot;English&quot;, 80),</span><br><span class="line">            new Student(&quot;yoni&quot;, &quot;Chiness&quot;, 98),</span><br><span class="line">            new Student(&quot;yoni&quot;, &quot;Math&quot;, 95),</span><br><span class="line">            new Student(&quot;taohai.wang&quot;, &quot;English&quot;, 50),</span><br><span class="line">            new Student(&quot;taohai.wang&quot;, &quot;Chiness&quot;, 72),</span><br><span class="line">            new Student(&quot;taohai.wang&quot;, &quot;Math&quot;, 41),</span><br><span class="line">            new Student(&quot;Seely&quot;, &quot;English&quot;, 88),</span><br><span class="line">            new Student(&quot;Seely&quot;, &quot;Chiness&quot;, 89),</span><br><span class="line">            new Student(&quot;Seely&quot;, &quot;Math&quot;, 92)</span><br><span class="line">    );</span><br><span class="line">    Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;();</span><br><span class="line">    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));</span><br><span class="line">    scoreMap.forEach((k, v) -&gt; System.out.println(&quot;key:&quot; + k + &quot;总分&quot; + &quot;value:&quot; + v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Student &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final String type;</span><br><span class="line">    private final int score;</span><br><span class="line"></span><br><span class="line">    public Student(String name, String type, int score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.type = type;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="集合的嵌套"><a href="#集合的嵌套" class="headerlink" title="集合的嵌套"></a><strong>集合的嵌套</strong></h3><p>既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();   //每一个映射都是 字符串&lt;-&gt;列表</span><br><span class="line">    map.put(&quot;卡布奇诺今犹在&quot;, new LinkedList&lt;&gt;());</span><br><span class="line">    map.put(&quot;不见当年倒茶人&quot;, new LinkedList&lt;&gt;());</span><br><span class="line">    System.out.println(map.keySet());</span><br><span class="line">    System.out.println(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Key获取到对应的值后，就是一个列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.get(&quot;卡布奇诺今犹在&quot;).add(10);</span><br><span class="line">System.out.println(map.get(&quot;卡布奇诺今犹在&quot;).get(0));</span><br></pre></td></tr></table></figure>

<p>让套娃继续下去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以使用List来套娃别的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流Stream和Optional的使用"><a href="#流Stream和Optional的使用" class="headerlink" title="流Stream和Optional的使用"></a><strong>流Stream和Optional的使用</strong></h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F723b4e9e03e9f1cbd9078f60b265e3ddc8a582aa.jpg&refer=http%3A%2F%2Fseo-1255598498.file.myqcloud.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634782830&t=8d9a60d60087bec5ce0d09b763eb3805">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F723b4e9e03e9f1cbd9078f60b265e3ddc8a582aa.jpg&amp;refer=http%3A%2F%2Fseo-1255598498.file.myqcloud.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634782830&amp;t=8d9a60d60087bec5ce0d09b763eb3805</a></p>
<p>它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(&quot;A&quot;);</span><br><span class="line">    list.add(&quot;B&quot;);</span><br><span class="line">    list.add(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">  	//移除为B的元素</span><br><span class="line">  	Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            if(iterator.next().equals(&quot;B&quot;)) iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  	//Stream操作</span><br><span class="line">    list = list     //链式调用</span><br><span class="line">            .stream()    //获取流</span><br><span class="line">            .filter(e -&gt; !e.equals(&quot;B&quot;))   //只允许所有不是B的元素通过流水线</span><br><span class="line">            .collect(Collectors.toList());   //将流水线中的元素重新收集起来，变回List</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">  	list.add(3);</span><br><span class="line"></span><br><span class="line">    list = list</span><br><span class="line">            .stream()</span><br><span class="line">      			.distinct()   //去重（使用equals判断）</span><br><span class="line">            .sorted((a, b) -&gt; b - a)    //进行倒序排列</span><br><span class="line">            .map(e -&gt; e+1)    //每个元素都要执行+1操作</span><br><span class="line">            .limit(2)    //只放行前两个元素</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）</p>
<p><strong>注意</strong>：不能认为每一步是直接依次执行的！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line"></span><br><span class="line">list = list</span><br><span class="line">        .stream()</span><br><span class="line">        .distinct()   //断点</span><br><span class="line">        .sorted((a, b) -&gt; b - a)</span><br><span class="line">        .map(e -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;&gt;&gt;&gt; &quot;+e);   //断点</span><br><span class="line">            return e+1;</span><br><span class="line">        &#125;)</span><br><span class="line">        .limit(2)   //断点</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">//实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！</span><br></pre></td></tr></table></figure>

<p>接下来，我们用一堆随机数来进行更多流操作的演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Random random = new Random();  //Random是一个随机数工具类</span><br><span class="line">    random</span><br><span class="line">            .ints(-100, 100)   //生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span><br><span class="line">            .limit(10)   //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span><br><span class="line">            .filter(i -&gt; i &lt; 0)   //只保留小于0的数字</span><br><span class="line">            .sorted()    //默认从小到大排序</span><br><span class="line">            .forEach(System.out::println);   //依次打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以生成一个统计实例来帮助我们快速进行统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Random random = new Random();  //Random是一个随机数工具类</span><br><span class="line">    IntSummaryStatistics statistics = random</span><br><span class="line">            .ints(0, 100)</span><br><span class="line">            .limit(100)</span><br><span class="line">            .summaryStatistics();    //获取语法统计实例</span><br><span class="line">    System.out.println(statistics.getMax());  //快速获取最大值</span><br><span class="line">    System.out.println(statistics.getCount());  //获取数量</span><br><span class="line">    System.out.println(statistics.getAverage());   //获取平均值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    list.add(4);</span><br><span class="line">    list.stream()</span><br><span class="line">            .mapToInt(i -&gt; i)    //将每一个元素映射为Integer类型（这里因为本来就是Integer）</span><br><span class="line">            .summaryStatistics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>flat</code>来对整个流进行进一步细分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(&quot;A,B&quot;);</span><br><span class="line">    list.add(&quot;C,D&quot;);</span><br><span class="line">    list.add(&quot;E,F&quot;);   //我们想让每一个元素通过,进行分割，变成独立的6个元素</span><br><span class="line">    list = list</span><br><span class="line">            .stream()    //生成流</span><br><span class="line">            .flatMap(e -&gt; Arrays.stream(e.split(&quot;,&quot;)))    //分割字符串并生成新的流</span><br><span class="line">            .collect(Collectors.toList());   //汇成新的List</span><br><span class="line">    System.out.println(list);   //得到结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(1);</span><br><span class="line">    list.add(2);</span><br><span class="line">    list.add(3);</span><br><span class="line">    int sum = list</span><br><span class="line">            .stream()</span><br><span class="line">            .reduce((a, b) -&gt; a + b)   //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span><br><span class="line">            .get();    //我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？</p>
<p>Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    if(str != null)&#123;   //当str不为空时添加元素到List中</span><br><span class="line">        list.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了Optional之后，我们就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    Optional&lt;String&gt; optional = Optional.ofNullable(str);   //转换为Optional</span><br><span class="line">    optional.ifPresent(System.out::println);  //当存在时再执行方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就类似于Kotlin中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str : String? = null</span><br><span class="line">str?.upperCase()</span><br></pre></td></tr></table></figure>

<p>我们可以选择直接get或是当值为null时，获取备选值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    Optional optional = Optional.ofNullable(str);   //转换为Optional（可空）</span><br><span class="line">    System.out.println(optional.orElse(&quot;lbwnb&quot;));</span><br><span class="line"> 		// System.out.println(optional.get());   这样会直接报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，Optional也支持过滤操作和映射操作，不过是对于单对象而言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = &quot;A&quot;;</span><br><span class="line">    Optional optional = Optional.ofNullable(str);   //转换为Optional（可空）</span><br><span class="line">    System.out.println(optional.filter(s -&gt; s.equals(&quot;B&quot;)).get());   //被过滤了，此时元素为null，获取时报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    String str = &quot;A&quot;;</span><br><span class="line">    Optional optional = Optional.ofNullable(str);   //转换为Optional（可空）</span><br><span class="line">    System.out.println(optional.map(s -&gt; s + &quot;A&quot;).get());   //在尾部追加一个A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他操作自学了解。</p>
<h3 id="Arrays和Collections的使用"><a href="#Arrays和Collections的使用" class="headerlink" title="Arrays和Collections的使用"></a><strong>Arrays和Collections的使用</strong></h3><p>Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This class contains various methods for manipulating arrays (such as</span><br><span class="line"> * sorting and searching). This class also contains a static factory</span><br><span class="line"> * that allows arrays to be viewed as lists. &lt;- 注意，这句话很关键</span><br><span class="line"> *</span><br><span class="line"> * @author Josh Bloch</span><br><span class="line"> * @author Neal Gafter</span><br><span class="line"> * @author John Rose</span><br><span class="line"> * @since  1.2</span><br><span class="line"> */</span><br><span class="line">public class Arrays &#123;</span><br></pre></td></tr></table></figure>

<p>由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;;</span><br><span class="line">    Arrays.sort(array);   //直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序）</span><br><span class="line">    System.out.println(array);  //由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果</span><br><span class="line">    System.out.println(Arrays.toString(array));  //我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;;</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    System.out.println(&quot;排序后的结果：&quot;+Arrays.toString(array));</span><br><span class="line">    System.out.println(&quot;目标元素3位置为：&quot;+Arrays.binarySearch(array, 3));  //二分搜素，必须是已经排序好的数组！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;;</span><br><span class="line">    Arrays</span><br><span class="line">            .stream(array)    //将数组转换为流进行操作</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;;</span><br><span class="line">    int[] array2 = Arrays.copyOf(array, array.length);  //复制一个一模一样的数组</span><br><span class="line">    System.out.println(Arrays.toString(array2));</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.equals(array, array2));  //比较两个数组是否值相同</span><br><span class="line"></span><br><span class="line">    Arrays.fill(array, 0);   //将数组的所有值全部填充为指定值</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    Arrays.setAll(array2, i -&gt; array2[i] + 2);  //依次计算每一个元素（注意i是下标位置）</span><br><span class="line">    System.out.println(Arrays.toString(array2));   //这里计算让每个元素值+2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：当二维数组使用<code>Arrays.equals()</code>进行比较以及<code>Arrays.toString()</code>进行打印时，还会得到我们想要的结果吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer[][] array = &#123;&#123;1, 5&#125;, &#123;2, 4&#125;, &#123;7, 3&#125;, &#123;6&#125;&#125;;</span><br><span class="line">    Integer[][] array2 = &#123;&#123;1, 5&#125;, &#123;2, 4&#125;, &#123;7, 3&#125;, &#123;6&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(array));    //这样还会得到我们想要的结果吗？</span><br><span class="line">    System.out.println(Arrays.equals(array2, array));    //这样还会得到true吗？</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.deepToString(array));   //使用deepToString就能到打印多维数组</span><br><span class="line">    System.out.println(Arrays.deepEquals(array2, array));   //使用deepEquals就能比较多维数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，一开始提到的当做List进行操作呢？我们可以使用<code>Arrays.asList()</code>来将数组转换为一个 <strong>固定长度的List</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(array);   //不支持基本类型数组，必须是对象类型数组</span><br><span class="line">    Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);  //也可以逐个添加，因为是可变参数</span><br><span class="line"></span><br><span class="line">    list.add(1);    //此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作</span><br><span class="line">    list.remove(0);   //同理，也不支持移除</span><br><span class="line"></span><br><span class="line">    list.set(0, 8);   //直接设置指定下标的值就可以</span><br><span class="line">    list.sort(Comparator.reverseOrder());   //也可以执行排序操作</span><br><span class="line">    System.out.println(list);   //也可以像List那样直接打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文字游戏：<code>allows arrays to be viewed as lists</code>，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。</p>
<p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Collections.max(list);</span><br><span class="line">    Collections.min(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。</p>
<hr>
<h2 id="集合类编程实战"><a href="#集合类编程实战" class="headerlink" title="集合类编程实战"></a><strong>集合类编程实战</strong></h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><strong>反转链表</strong></h3><p>1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9  转换为 1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9</p>
<p>现在有一个单链表，尝试将其所有节点倒序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node head = new Node(1);</span><br><span class="line">        head.next = new Node(3);</span><br><span class="line">        head.next.next = new Node(5);</span><br><span class="line">        head.next.next.next = new Node(7);</span><br><span class="line">        head.next.next.next.next = new Node(9);</span><br><span class="line"></span><br><span class="line">        head = reverse(head);</span><br><span class="line"></span><br><span class="line">        while (head != null)&#123;</span><br><span class="line">            System.out.println(head.value+&quot; &quot;);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        public int value;</span><br><span class="line">        public Node next;</span><br><span class="line"></span><br><span class="line">        public Node(int data) &#123;</span><br><span class="line">            this.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Node reverse(Node head) &#123;</span><br><span class="line">        //在这里实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><strong>重建二叉树</strong></h3><p>现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。</p>
<p><a target="_blank" rel="noopener" href="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTEwMTExNTE3NDcx?x-oss-process=image/format,png">https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTEwMTExNTE3NDcx?x-oss-process=image/format,png</a></p>
<h3 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a><strong>实现计算器</strong></h3><p>实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3/1.321，得到结果为：2.2</p>
<h3 id="字符串匹配（KMP算法）"><a href="#字符串匹配（KMP算法）" class="headerlink" title="字符串匹配（KMP算法）"></a><strong>字符串匹配（KMP算法）</strong></h3><p>现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。</p>
<h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><p><strong>注意：</strong>这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p>
<p>I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。</p>
<p>我们可以大致看一下整个计算机的总线结构：</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1896043%2F202005%2F1896043-20200507143508957-1866569205.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637387700&t=e6a5ade66f8e4af2ac64d12e6dd77dec">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1896043%2F202005%2F1896043-20200507143508957-1866569205.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637387700&amp;t=e6a5ade66f8e4af2ac64d12e6dd77dec</a></p>
<p>常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p>
<p>而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p>
<p>JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO，</p>
<p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a><strong>文件流</strong></h2><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p>
<h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a><strong>文件字节流</strong></h3><p>首先介绍一下FileInputStream，通过它来获取文件的输入流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        FileInputStream inputStream = new FileInputStream(&quot;路径&quot;);</span><br><span class="line">        //路径支持相对路径和绝对路径</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\</code>，但是不能写为<code>\</code>因为它是转义字符！</p>
<p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    FileInputStream inputStream = null;    //定义可以先放在try外部</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream = new FileInputStream(&quot;路径&quot;);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;    //建议在finally中进行，因为这个是任何情况都必须要执行的！</span><br><span class="line">            if(inputStream != null) inputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    //注意，这种语法只支持实现了AutoCloseable接口的类！</span><br><span class="line">    try(FileInputStream inputStream = new FileInputStream(&quot;路径&quot;)) &#123;   //直接在try()中定义要在完成之后释放的资源</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;   //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    //无需再编写finally语句块，因为在最后自动帮我们调用了close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后为了方便，我们都使用此语法进行教学。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //test.txt：a</span><br><span class="line">    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class="line">        //使用read()方法进行字符读取</span><br><span class="line">        System.out.println((char) inputStream.read());  //读取一个字节的数据（英文字母只占1字节，中文占2字节）</span><br><span class="line">        System.out.println(inputStream.read());   //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //test.txt：abcd</span><br><span class="line">    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        while ((tmp = inputStream.read()) != -1)&#123;   //通过while循环来一次性读完内容</span><br><span class="line">            System.out.println((char)tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class="line">    System.out.println(inputStream.available());  //查看剩余数量</span><br><span class="line">&#125;catch (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //test.txt：abcd</span><br><span class="line">    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class="line">        byte[] bytes = new byte[inputStream.available()];   //我们可以提前准备好合适容量的byte数组来存放</span><br><span class="line">        System.out.println(inputStream.read(bytes));   //一次性读取全部内容（返回值是读取的字节数）</span><br><span class="line">        System.out.println(new String(bytes));   //通过String(byte[])构造方法得到字符串</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以控制要读取数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(inputStream.read(bytes, 1, 2));   //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p>
<p>通过<code>skip()</code>方法可以跳过指定数量的字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //test.txt：abcd</span><br><span class="line">    try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class="line">        System.out.println(inputStream.skip(1));</span><br><span class="line">        System.out.println((char) inputStream.read());   //跳过了一个字节</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p>
<p>既然有输入流，那么文件输出流也是必不可少的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span><br><span class="line">    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;)) &#123;</span><br><span class="line">        //注意：若此文件不存在，会直接创建这个文件！</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;)) &#123;</span><br><span class="line">        outputStream.write(&#x27;c&#x27;);   //同read一样，可以直接写入内容</span><br><span class="line">      	outputStream.write(&quot;lbwnb&quot;.getBytes());   //也可以直接写入byte[]</span><br><span class="line">      	outputStream.write(&quot;lbwnb&quot;.getBytes(), 0, 1);  //同上输入流</span><br><span class="line">      	outputStream.flush();  //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;, true)) &#123;</span><br><span class="line">        outputStream.write(&quot;lb&quot;.getBytes());   //现在只会进行追加写入，而不是直接替换原文件内容</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;);</span><br><span class="line">        FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;   //可以写入多个</span><br><span class="line">        byte[] bytes = new byte[10];    //使用长度为10的byte[]做传输媒介</span><br><span class="line">        int tmp;   //存储本地读取字节数</span><br><span class="line">        while ((tmp = inputStream.read(bytes)) != -1)&#123;   //直到读取完成为止</span><br><span class="line">            outputStream.write(bytes, 0, tmp);    //写入对应长度的数据到输出流</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a><strong>文件字符流</strong></h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(FileReader reader = new FileReader(&quot;test.txt&quot;))&#123;</span><br><span class="line">      	reader.skip(1);   //现在跳过的是一个字符</span><br><span class="line">        System.out.println((char) reader.read());   //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，字符流只支持<code>char[]</code>类型作为存储：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(FileReader reader = new FileReader(&quot;test.txt&quot;))&#123;</span><br><span class="line">        char[] str = new char[10];</span><br><span class="line">        reader.read(str);</span><br><span class="line">        System.out.println(str);   //直接读取到char[]中</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然有了Reader肯定也有Writer：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(FileWriter writer = new FileWriter(&quot;output.txt&quot;))&#123;</span><br><span class="line">      	writer.getEncoding();   //支持获取编码（不同的文本文件可能会有不同的编码类型）</span><br><span class="line">       writer.write(&#x27;牛&#x27;);</span><br><span class="line">       writer.append(&#x27;牛&#x27;);   //其实功能和write一样</span><br><span class="line">      	writer.flush();   //刷新</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified character to this writer.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;</span><br><span class="line"> * behaves in exactly the same way as the invocation</span><br><span class="line"> *</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     out.write(c) &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param  c</span><br><span class="line"> *         The 16-bit character to append</span><br><span class="line"> *</span><br><span class="line"> * @return  This writer</span><br><span class="line"> *</span><br><span class="line"> * @throws  IOException</span><br><span class="line"> *          If an I/O error occurs</span><br><span class="line"> *</span><br><span class="line"> * @since 1.5</span><br><span class="line"> */</span><br><span class="line">public Writer append(char c) throws IOException &#123;</span><br><span class="line">    write(c);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p>
<p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件</p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a><strong>File类</strong></h3><p>File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    File file = new File(&quot;test.txt&quot;);   //直接创建文件对象，可以是相对路径，也可以是绝对路径</span><br><span class="line">    System.out.println(file.exists());   //此文件是否存在</span><br><span class="line">    System.out.println(file.length());   //获取文件的大小</span><br><span class="line">    System.out.println(file.isDirectory());   //是否为一个文件夹</span><br><span class="line">    System.out.println(file.canRead());   //是否可读</span><br><span class="line">    System.out.println(file.canWrite());   //是否可写</span><br><span class="line">    System.out.println(file.canExecute());   //是否可执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/&quot;);</span><br><span class="line">System.out.println(Arrays.toString(file.list()));   //快速获取文件夹下的文件名称列表</span><br><span class="line">for (File f : file.listFiles())&#123;   //所有子文件的File对象</span><br><span class="line">    System.out.println(f.getAbsolutePath());   //获取文件的绝对路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;test.txt&quot;);</span><br><span class="line">try (FileInputStream inputStream = new FileInputStream(file))&#123;   //直接做参数</span><br><span class="line">    System.out.println(inputStream.available());</span><br><span class="line">&#125;catch (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p>
<hr>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a><strong>缓冲流</strong></h2><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.wityx.com%2Fimage%2F201908%2F480873DBD936EBA9518F721ACDC22BFE.png&refer=http%3A%2F%2Fwww.wityx.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637457276&t=b4f7d52f08d9d5815baca0b21a01f925">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.wityx.com%2Fimage%2F201908%2F480873DBD936EBA9518F721ACDC22BFE.png&amp;refer=http%3A%2F%2Fwww.wityx.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637457276&amp;t=b4f7d52f08d9d5815baca0b21a01f925</a></p>
<h3 id="缓冲字节流"><a href="#缓冲字节流" class="headerlink" title="缓冲字节流"></a><strong>缓冲字节流</strong></h3><p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;   //传入FileInputStream</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());   //操作和原来的流是一样的</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    byte[] buffer;</span><br><span class="line">    while ( (buffer = buf) != null) &#123;</span><br><span class="line">        if (bufUpdater.compareAndSet(this, buffer, null)) &#123;  //CAS无锁算法，并发会用到，暂时不管</span><br><span class="line">            InputStream input = in;</span><br><span class="line">            in = null;</span><br><span class="line">            if (input != null)</span><br><span class="line">                input.close();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // Else retry in case a new buf was CASed in fill()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p>
<p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The internal buffer array where the data is stored. When necessary,</span><br><span class="line"> * it may be replaced by another array of</span><br><span class="line"> * a different size.</span><br><span class="line"> */</span><br><span class="line">protected volatile byte buf[];</span><br></pre></td></tr></table></figure>

<p>I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Marks the current position in this input stream. A subsequent</span><br><span class="line"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span><br><span class="line"> * the last marked position so that subsequent reads re-read the same bytes.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span><br><span class="line"> * allow that many bytes to be read before the mark position gets</span><br><span class="line"> * invalidated.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @param   readlimit   the maximum limit of bytes that can be read before</span><br><span class="line"> *                      the mark position becomes invalid.</span><br><span class="line"> * @see     java.io.FilterInputStream#in</span><br><span class="line"> * @see     java.io.FilterInputStream#reset()</span><br><span class="line"> */</span><br><span class="line">public synchronized void mark(int readlimit) &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        bufferedInputStream.mark(1);   //只保留之后的1个字符</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">        bufferedInputStream.reset();   //回到mark时的位置</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;), 1))&#123;  //将缓冲区大小设置为1</span><br><span class="line">        bufferedInputStream.mark(1);   //只保留之后的1个字符</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());   //已经超过了readlimit，继续读取会导致mark失效</span><br><span class="line">        bufferedInputStream.reset();   //mark已经失效，无法reset()</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">        System.out.println((char) bufferedInputStream.read());</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123;</span><br><span class="line">        outputStream.write(&quot;lbwnb&quot;.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作和FileOutputStream一致，这里就不多做介绍了。</p>
<h3 id="缓冲字符流"><a href="#缓冲字符流" class="headerlink" title="缓冲字符流"></a><strong>缓冲字符流</strong></h3><p>缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        System.out.println((char) reader.read());</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用和reader也是一样的，内部也包含一个缓存数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private char cb[];</span><br></pre></td></tr></table></figure>

<p>相比Reader更方便的是，它支持按行读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        System.out.println(reader.readLine());   //按行读取</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        reader</span><br><span class="line">                .lines()</span><br><span class="line">                .limit(2)</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        reader.mark(1);</span><br><span class="line">        System.out.println((char) reader.read());</span><br><span class="line">        reader.reset();</span><br><span class="line">        System.out.println((char) reader.read());</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (BufferedWriter reader = new BufferedWriter(new FileWriter(&quot;output.txt&quot;)))&#123;</span><br><span class="line">        reader.newLine();   //使用newLine进行换行</span><br><span class="line">        reader.write(&quot;汉堡做滴彳亍不彳亍&quot;);   //可以直接写入一个字符串</span><br><span class="line">      	reader.flush();   //清空缓冲区</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><strong>转换流</strong></h2><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(&quot;test.txt&quot;)))&#123;  //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span><br><span class="line">        writer.write(&quot;lbwnb&quot;);   //以操作Writer的样子写入OutputStream</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(InputStreamReader reader = new InputStreamReader(new FileInputStream(&quot;test.txt&quot;)))&#123;  //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span><br><span class="line">        System.out.println((char) reader.read());</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p>
<hr>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a><strong>打印流</strong></h2><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final static PrintStream out = null;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try(PrintStream stream = new PrintStream(new FileOutputStream(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        stream.println(&quot;lbwnb&quot;);   //其实System.out就是一个PrintStream</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20180906143936647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGkxMzg5Nzc0MTU1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">https://img-blog.csdn.net/20180906143936647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGkxMzg5Nzc0MTU1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</a></p>
<p>因此实际上内部还包含这两个内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Track both the text- and character-output streams, so that their buffers</span><br><span class="line"> * can be flushed without flushing the entire stream.</span><br><span class="line"> */</span><br><span class="line">private BufferedWriter textOut;</span><br><span class="line">private OutputStreamWriter charOut;</span><br></pre></td></tr></table></figure>

<p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p>
<hr>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a><strong>数据流</strong></h2><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;</span><br><span class="line">        System.out.println(dataInputStream.readBoolean());   //直接将数据读取为任意基本数据类型</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于写入基本数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123;</span><br><span class="line">        dataOutputStream.writeBoolean(false);</span><br><span class="line">    &#125;catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a><strong>对象流</strong></h2><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;));</span><br><span class="line">         ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123;</span><br><span class="line">        People people = new People(&quot;lbw&quot;);</span><br><span class="line">        outputStream.writeObject(people);</span><br><span class="line">      	outputStream.flush();</span><br><span class="line">        people = (People) inputStream.readObject();</span><br><span class="line">        System.out.println(people.name);</span><br><span class="line">    &#125;catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class People implements Serializable&#123;   //必须实现Serializable接口才能被序列化</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public People(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class People implements Serializable&#123;</span><br><span class="line">    private static final long serialVersionUID = 123456;   //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public People(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生版本不匹配时，会无法反序列化为对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567</span><br><span class="line">	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)</span><br><span class="line">	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003)</span><br><span class="line">	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850)</span><br><span class="line">	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160)</span><br><span class="line">	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667)</span><br><span class="line">	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503)</span><br><span class="line">	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461)</span><br><span class="line">	at com.test.Main.main(Main.java:27)</span><br></pre></td></tr></table></figure>

<p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;));</span><br><span class="line">         ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123;</span><br><span class="line">        People people = new People(&quot;lbw&quot;);</span><br><span class="line">        outputStream.writeObject(people);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        people = (People) inputStream.readObject();</span><br><span class="line">        System.out.println(people.name);  //虽然能得到对象，但是name属性并没有保存，因此为null</span><br><span class="line">    &#125;catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class People implements Serializable&#123;</span><br><span class="line">    private static final long serialVersionUID = 1234567;</span><br><span class="line"></span><br><span class="line">    transient String name;</span><br><span class="line"></span><br><span class="line">    public People(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p>
<hr>
<h2 id="Java-I-O编程实战"><a href="#Java-I-O编程实战" class="headerlink" title="Java I/O编程实战"></a><strong>Java I/O编程实战</strong></h2><h3 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a><strong>图书管理系统</strong></h3><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p>
<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><p><strong>注意：</strong>本章节会涉及到 <strong>操作系统</strong> 相关知识。</p>
<p>在了解多线程之前，让我们回顾一下<code>操作系统</code>中提到的进程概念：</p>
<p>进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过<code>时间片轮转调度</code>算法，来实现多个进程的同时运行。</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhiphotos.baidu.com%2Fdoc%2Fpic%2Fitem%2Faec379310a55b3193e6caaf24aa98226cefc179b.jpg&refer=http%3A%2F%2Fhiphotos.baidu.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637499744&t=1df3c2095bc9a8cbe8cd9d0974644b7c">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhiphotos.baidu.com%2Fdoc%2Fpic%2Fitem%2Faec379310a55b3193e6caaf24aa98226cefc179b.jpg&amp;refer=http%3A%2F%2Fhiphotos.baidu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637499744&amp;t=1df3c2095bc9a8cbe8cd9d0974644b7c</a></p>
<p>在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.51cto.com%2Fwyfs02%2FM00%2F84%2F3A%2FwKiom1eIqY7il2J7AAAyvcssSjs721.gif&refer=http%3A%2F%2Fs2.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637474421&t=aef9a39ea3a09d6d67e8d4b769036446">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.51cto.com%2Fwyfs02%2FM00%2F84%2F3A%2FwKiom1eIqY7il2J7AAAyvcssSjs721.gif&amp;refer=http%3A%2F%2Fs2.51cto.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637474421&amp;t=aef9a39ea3a09d6d67e8d4b769036446</a></p>
<p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p>
<p>在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行<code>main()</code>方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法<strong>同时</strong>在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadMXBean bean = ManagementFactory.getThreadMXBean();</span><br><span class="line">    long[] ids = bean.getAllThreadIds();</span><br><span class="line">    ThreadInfo[] infos = bean.getThreadInfo(ids);</span><br><span class="line">    for (ThreadInfo info : infos) &#123;</span><br><span class="line">        System.out.println(info.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。</p>
<hr>
<h2 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a><strong>线程的创建和启动</strong></h2><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&#x27;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好后，通过调用<code>start()</code>方法来运行此线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;    //直接编写逻辑</span><br><span class="line">        System.out.println(&quot;我是另一个线程！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();   //调用此方法来开始执行此线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;我是线程：&quot;+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(&quot;我正在计算 0-10000 之间所有数的和...&quot;);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt;= 10000; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;结果：&quot;+sum);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(&quot;我是主线程！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;我是一号线程：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;我是二号线程：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！</p>
<p><strong>注意</strong>：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liuhaihua.cn%2Fwp-content%2Fuploads%2F2019%2F09%2F3AfuQrV.png&refer=http%3A%2F%2Fwww.liuhaihua.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637477978&t=d986b270854b3d7c54f816f9103084bc">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liuhaihua.cn%2Fwp-content%2Fuploads%2F2019%2F09%2F3AfuQrV.png&amp;refer=http%3A%2F%2Fwww.liuhaihua.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637477978&amp;t=d986b270854b3d7c54f816f9103084bc</a></p>
<p>实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用<code>sleep()</code>方法来让当前线程休眠一段时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    System.out.println(&quot;l&quot;);</span><br><span class="line">    Thread.sleep(1000);    //休眠时间，以毫秒为单位，1000ms = 1s</span><br><span class="line">    System.out.println(&quot;b&quot;);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    System.out.println(&quot;w&quot;);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    System.out.println(&quot;nb!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>stop()</code>方法来强行终止此线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        Thread me = Thread.currentThread();   //获取当前线程对象</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;打印:&quot;+i);</span><br><span class="line">            if(i == 20) me.stop();  //此方法会直接终止此线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p>
<p><strong>思考</strong>：猜猜以下程序输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static int value = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) value++;</span><br><span class="line">        System.out.println(&quot;线程1完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) value++;</span><br><span class="line">        System.out.println(&quot;线程2完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。</p>
<hr>
<h2 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a><strong>线程的休眠和中断</strong></h2><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p>
<ul>
<li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li>
<li>当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li>
<li>当线程出现异常或错误 / 被<code>stop()</code> 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。</li>
</ul>
<p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;l&quot;);</span><br><span class="line">            Thread.sleep(1000);   //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）</span><br><span class="line">            System.out.println(&quot;b&quot;);    //调用sleep后，线程会直接进入到等待状态，直到时间结束</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用<code>sleep()</code>方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10000);  //休眠10秒</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);   //休眠3秒，一定比线程t先醒来</span><br><span class="line">        t.interrupt();   //调用t的interrupt方法</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程开始运行！&quot;);</span><br><span class="line">        while (true)&#123;   //无限循环</span><br><span class="line">            if(Thread.currentThread().isInterrupted())&#123;   //判断是否存在中断标志</span><br><span class="line">                break;   //响应中断</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程被中断了！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);   //休眠3秒，一定比线程t先醒来</span><br><span class="line">        t.interrupt();   //调用t的interrupt方法</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程开始运行！&quot;);</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(Thread.currentThread().isInterrupted())&#123;   //判断是否存在中断标志</span><br><span class="line">                System.out.println(&quot;发现中断信号，复位，继续运行...&quot;);</span><br><span class="line">                Thread.interrupted();  //复位中断标记（返回值是当前是否有中断标记，这里不用管）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);   //休眠3秒，一定比线程t先醒来</span><br><span class="line">        t.interrupt();   //调用t的interrupt方法</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程开始运行！&quot;);</span><br><span class="line">        Thread.currentThread().suspend();   //暂停此线程</span><br><span class="line">        System.out.println(&quot;线程继续运行！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);   //休眠3秒，一定比线程t先醒来</span><br><span class="line">        t.resume();   //恢复此线程</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。</p>
<hr>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a><strong>线程的优先级</strong></h2><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p>
<ul>
<li>MIN_PRIORITY 最低优先级</li>
<li>MAX_PRIORITY 最高优先级</li>
<li>NOM_PRIORITY 常规优先级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程开始运行！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.setPriority(Thread.MIN_PRIORITY);  //通过使用setPriority方法来设定优先级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</p>
<h2 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a><strong>线程的礼让和加入</strong></h2><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程1开始运行！&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            if(i % 5 == 0) &#123;</span><br><span class="line">                System.out.println(&quot;让位！&quot;);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;1打印：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程1结束！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程2开始运行！&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;2打印：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。</p>
<p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程1开始运行！&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;1打印：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程1结束！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程2开始运行！&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;2打印：&quot;+i);</span><br><span class="line">            if(i == 10)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;线程1加入到此线程！&quot;);</span><br><span class="line">                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;开始运行！&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;打印：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程1结束！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;线程2开始运行！&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            System.out.println(&quot;2打印：&quot;+i);</span><br><span class="line">            if(i == 10)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;线程1加入到此线程！&quot;);</span><br><span class="line">                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。</p>
<hr>
<h2 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a><strong>线程锁和线程同步</strong></h2><p>在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fvlambda.com%2Fimg%3Furl%3Dhttps%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2F2LlmEpiamhyq7hTfsoWa1GMIQlOtRuD8SScvIeB3KD7w4OoGu8wx13lBjMJLhYgYqTHND48X05m901TIEicGg49w%2F640%3Fwx_fmt%3Dpng&refer=http%3A%2F%2Fvlambda.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637562962&t=830ccc4dbe09f2699660bfcc9a292c63">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fvlambda.com%2Fimg%3Furl%3Dhttps%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2F2LlmEpiamhyq7hTfsoWa1GMIQlOtRuD8SScvIeB3KD7w4OoGu8wx13lBjMJLhYgYqTHND48X05m901TIEicGg49w%2F640%3Fwx_fmt%3Dpng&amp;refer=http%3A%2F%2Fvlambda.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637562962&amp;t=830ccc4dbe09f2699660bfcc9a292c63</a></p>
<p>线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在<code>计算机组成原理</code>中学习的多处理器高速缓存机制：</p>
<p><a target="_blank" rel="noopener" href="https://note.youdao.com/yws/api/personal/file/WEBb1fa2c9cd0784fb19f0d8ebeb8e00976?method=download&shareKey=8d48a5816e60b026adfa21e6735b5e31">https://note.youdao.com/yws/api/personal/file/WEBb1fa2c9cd0784fb19f0d8ebeb8e00976?method=download&amp;shareKey=8d48a5816e60b026adfa21e6735b5e31</a></p>
<p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。</p>
<p>实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！</p>
<h3 id="悬念破案"><a href="#悬念破案" class="headerlink" title="悬念破案"></a><strong>悬念破案</strong></h3><p>我们再来回顾一下之前留给大家的悬念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static int value = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) value++;</span><br><span class="line">        System.out.println(&quot;线程1完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) value++;</span><br><span class="line">        System.out.println(&quot;线程2完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F3154ff892af3cb3373a3b6b82b501a1d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637565388&t=20091d33bae457edc36af7718ef1325b">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F3154ff892af3cb3373a3b6b82b501a1d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&amp;refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637565388&amp;t=20091d33bae457edc36af7718ef1325b</a></p>
<p>那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行）</p>
<h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a><strong>线程锁</strong></h3><p>通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static int value = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            synchronized (Main.class)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程1完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            synchronized (Main.class)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程2完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！</p>
<p>当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法）</p>
<p>那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static int value = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Main main1 = new Main();</span><br><span class="line">    Main main2 = new Main();</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            synchronized (main1)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程1完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            synchronized (main2)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程2完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。</p>
<p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static int value = 0;</span><br><span class="line"></span><br><span class="line">private static synchronized void add()&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) add();</span><br><span class="line">        System.out.println(&quot;线程1完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) add();</span><br><span class="line">        System.out.println(&quot;线程2完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p>其实死锁的概念在<code>操作系统</code>中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-9852c978350cc5e8641ba778619351bb_b.png&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637568214&t=7740dd98b8e1c4a3bfbd94a30e7f9ff8">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-9852c978350cc5e8641ba778619351bb_b.png&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637568214&amp;t=7740dd98b8e1c4a3bfbd94a30e7f9ff8</a></p>
<p>我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Object o1 = new Object();</span><br><span class="line">    Object o2 = new Object();</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (o1)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                synchronized (o2)&#123;</span><br><span class="line">                    System.out.println(&quot;线程1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (o2)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                synchronized (o1)&#123;</span><br><span class="line">                    System.out.println(&quot;线程2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nagocoler@NagodeMacBook-Pro ~ % jps</span><br><span class="line">51592 Launcher</span><br><span class="line">51690 Jps</span><br><span class="line">14955</span><br><span class="line">51693 Main</span><br><span class="line">nagocoler@NagodeMacBook-Pro ~ % jstack 51693</span><br><span class="line">...</span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">	at com.test.Main.lambda$main$1(Main.java:46)</span><br><span class="line">	- waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object)</span><br><span class="line">	at com.test.Main$$Lambda$2/1867750575.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">	at com.test.Main.lambda$main$0(Main.java:34)</span><br><span class="line">	- waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object)</span><br><span class="line">	at com.test.Main$$Lambda$1/396873410.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。</p>
<p>不推荐使用 <code>suspend()</code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p>
<h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a><strong>wait和notify方法</strong></h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Object o1 = new Object();</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (o1)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;开始等待&quot;);</span><br><span class="line">                o1.wait();     //进入等待状态并释放锁</span><br><span class="line">                System.out.println(&quot;等待结束！&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (o1)&#123;</span><br><span class="line">            System.out.println(&quot;开始唤醒！&quot;);</span><br><span class="line">            o1.notify();     //唤醒处于等待状态的线程</span><br><span class="line">          	for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">               	System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">          	//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p>
<p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a><strong>ThreadLocal的使用</strong></h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？</p>
<p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png" alt="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png"></p>
<p>我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;();  //注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        local.set(&quot;lbwnb&quot;);   //将变量的值给予ThreadLocal</span><br><span class="line">        System.out.println(&quot;变量值已设定！&quot;);</span><br><span class="line">        System.out.println(local.get());   //尝试获取ThreadLocal中存放的变量</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(local.get());   //尝试获取ThreadLocal中存放的变量</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(3000);    //间隔三秒</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;();  //注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        local.set(&quot;lbwnb&quot;);   //将变量的值给予ThreadLocal</span><br><span class="line">        System.out.println(&quot;线程1变量值已设定！&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);    //间隔2秒</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程1读取变量值：&quot;);</span><br><span class="line">        System.out.println(local.get());   //尝试获取ThreadLocal中存放的变量</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        local.set(&quot;yyds&quot;);   //将变量的值给予ThreadLocal</span><br><span class="line">        System.out.println(&quot;线程2变量值已设定！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(1000);    //间隔1秒</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。</p>
<p>我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;();</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">       local.set(&quot;lbwnb&quot;);</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(local.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用InheritableThreadLocal来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = new InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">       local.set(&quot;lbwnb&quot;);</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(local.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p>
<hr>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h2><p>我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new TimerTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start();   //创建并启动此定时任务</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class TimerTask&#123;</span><br><span class="line">    Runnable task;</span><br><span class="line">    long time;</span><br><span class="line"></span><br><span class="line">    public TimerTask(Runnable runnable, long time)&#123;</span><br><span class="line">        this.task = runnable;</span><br><span class="line">        this.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start()&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">                task.run();   //休眠后再运行</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new TimerLoopTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start();   //创建并启动此定时任务</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class TimerLoopTask&#123;</span><br><span class="line">    Runnable task;</span><br><span class="line">    long loopTime;</span><br><span class="line"></span><br><span class="line">    public TimerLoopTask(Runnable runnable, long loopTime)&#123;</span><br><span class="line">        this.task = runnable;</span><br><span class="line">        this.loopTime = loopTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start()&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true)&#123;   //无限循环执行</span><br><span class="line">                    Thread.sleep(loopTime);</span><br><span class="line">                    task.run();   //休眠后再运行</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。</p>
<p>但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Timer timer = new Timer();    //创建定时器对象</span><br><span class="line">    timer.schedule(new TimerTask() &#123;   //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());    //打印当前线程名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000);    //执行一个延时任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Timer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The timer task queue.  This data structure is shared with the timer</span><br><span class="line">     * thread.  The timer produces tasks, via its various schedule calls,</span><br><span class="line">     * and the timer thread consumes, executing timer tasks as appropriate,</span><br><span class="line">     * and removing them from the queue when they&#x27;re obsolete.</span><br><span class="line">     */</span><br><span class="line">    private final TaskQueue queue = new TaskQueue();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The timer thread.</span><br><span class="line">     */</span><br><span class="line">    private final TimerThread thread = new TimerThread(queue);</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Timer(String name) &#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mainLoop();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // Someone killed this Thread, behave as if Timer cancelled</span><br><span class="line">        synchronized(queue) &#123;</span><br><span class="line">            newTasksMayBeScheduled = false;</span><br><span class="line">            queue.clear();  // Eliminate obsolete references</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The main timer loop.  (See class comment.)</span><br><span class="line"> */</span><br><span class="line">private void mainLoop() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">       TimerTask task;</span><br><span class="line">       boolean taskFired;</span><br><span class="line">       synchronized(queue) &#123;</span><br><span class="line">         	// Wait for queue to become non-empty</span><br><span class="line">          while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。</span><br><span class="line">                queue.wait();</span><br><span class="line">          if (queue.isEmpty())</span><br><span class="line">             break;    //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程</span><br><span class="line">                      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newTasksMayBeScheduled</code>实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用<code>cancel()</code>方法来关闭它的工作线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        thread.newTasksMayBeScheduled = false;</span><br><span class="line">        queue.clear();</span><br><span class="line">        queue.notify();  //唤醒wait使得工作线程结束</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们可以在使用完成后，调用Timer的<code>cancel()</code>方法以正常退出我们的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Timer timer = new Timer();</span><br><span class="line">    timer.schedule(new TimerTask() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            timer.cancel();  //结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a><strong>守护线程</strong></h2><p>不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序正常运行中...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);   <span class="comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在守护线程中产生的新线程也是守护的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序正常运行中...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        it.start();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);   <span class="comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="再谈集合类并行方法"><a href="#再谈集合类并行方法" class="headerlink" title="再谈集合类并行方法"></a><strong>再谈集合类并行方法</strong></h2><p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line">    list</span><br><span class="line">            .parallelStream()    <span class="comment">//获得并行流</span></span><br><span class="line">            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; -&gt; &quot;</span>+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用<code>forEachOrdered()</code>方法来使用单线程维持原本的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line">    list</span><br><span class="line">            .parallelStream()    <span class="comment">//获得并行流</span></span><br><span class="line">            .forEachOrdered(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Arrays.parallelSort(arr);   <span class="comment">//使用多线程进行并行排序，效率更高</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Arrays.parallelSetAll(arr, i -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！</p>
<hr>
<h2 id="Java多线程编程实战"><a href="#Java多线程编程实战" class="headerlink" title="Java多线程编程实战"></a><strong>Java多线程编程实战</strong></h2><p>这是整个教程最后一个编程实战内容了，下一章节为<code>反射</code>一般开发者使用比较少，属于选学内容，不编排编程实战课程。</p>
<h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a><strong>生产者与消费者</strong></h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p>
<p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p>
<h1 id="Java反射和注解"><a href="#Java反射和注解" class="headerlink" title="Java反射和注解"></a>Java反射和注解</h1><p><strong>注意：</strong>本章节涉及到JVM相关底层原理，难度会有一些大。</p>
<p>反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。</p>
<p>简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！</p>
<h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a><strong>Java类加载机制</strong></h2><p>在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：</p>
<p><a target="_blank" rel="noopener" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.itboth.com%2F60%2F50%2FUrUVN3.png&refer=http%3A%2F%2Fimg3.itboth.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637635409&t=f25ea82c853619c26897ff5b4d041d5b">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.itboth.com%2F60%2F50%2FUrUVN3.png&amp;refer=http%3A%2F%2Fimg3.itboth.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637635409&amp;t=f25ea82c853619c26897ff5b4d041d5b</a></p>
<p>在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！</p>
<p><strong>思考：</strong>既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;    <span class="comment">//JDK提供的String类也是</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我姓🐴，我叫🐴nb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，会出现以下报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure>

<p>但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的<code>双亲委派机制</code>在保护Java程序的正常运行：</p>
<p><img src="https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70"></p>
<p>实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到<code>main</code>方法了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Main.class.getClassLoader());   <span class="comment">//查看当前类的类加载器</span></span><br><span class="line">        System.out.println(Main.class.getClassLoader().getParent());  <span class="comment">//父加载器</span></span><br><span class="line">        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="comment">//爷爷加载器</span></span><br><span class="line">        System.out.println(String.class.getClassLoader());   <span class="comment">//String类的加载器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。</p>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a><strong>Class对象</strong></h2><p>通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;String&gt; clazz = String.class;   <span class="comment">//使用class关键字，通过类名获取</span></span><br><span class="line">    Class&lt;?&gt; clazz2 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);   <span class="comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span></span><br><span class="line">    Class&lt;?&gt; clazz3 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cpdd&quot;</span>).getClass();  <span class="comment">//通过实例对象获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了<code>?</code>通配符作为返回值，但是实际上都和第一个返回的是同一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; clazz = String.class;   <span class="comment">//使用class关键字，通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz2 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);   <span class="comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span></span><br><span class="line">Class&lt;?&gt; clazz3 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cpdd&quot;</span>).getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(clazz == clazz2);</span><br><span class="line">System.out.println(clazz == clazz3);</span><br></pre></td></tr></table></figure>

<p>通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = <span class="type">int</span>.class;   <span class="comment">//基本数据类型有Class对象吗？</span></span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Class&#125; instance representing the primitive type</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return the Virtual Machine&#x27;s Class object for the named</span></span><br><span class="line"><span class="comment"> * primitive type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);   <span class="comment">//C++实现，并非Java定义</span></span><br></pre></td></tr></table></figure>

<p>每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = <span class="type">int</span>.class;</span><br><span class="line">    System.out.println(Integer.TYPE == <span class="type">int</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.TYPE == Integer.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;String[]&gt; clazz = String[].class;</span><br><span class="line">    System.out.println(clazz.getName());  <span class="comment">//获取类名称（得到的是包名+类名的完整名称）</span></span><br><span class="line">    System.out.println(clazz.getSimpleName());</span><br><span class="line">    System.out.println(clazz.getTypeName());</span><br><span class="line">    System.out.println(clazz.getClassLoader());   <span class="comment">//获取它的类加载器</span></span><br><span class="line">    System.out.println(clazz.cast(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;10&quot;</span>)));   <span class="comment">//强制类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈instanceof"><a href="#再谈instanceof" class="headerlink" title="再谈instanceof"></a><strong>再谈instanceof</strong></h3><p>正常情况下，我们使用instanceof进行类型比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(str <span class="keyword">instanceof</span> String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(str.getClass() == String.class);   <span class="comment">//直接判断是否为这个类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用<code>asSubClass()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i.getClass().asSubclass(Number.class);   <span class="comment">//当Integer不是Number的子类时，会产生异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取父类信息"><a href="#获取父类信息" class="headerlink" title="获取父类信息"></a><strong>获取父类信息</strong></h3><p>通过<code>getSuperclass()</code>方法，我们可以获取到父类的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(i.getClass().getSuperclass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>getGenericSuperclass()</code>获取父类的原始类型的Type：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> i.getClass().getGenericSuperclass();</span><br><span class="line">    System.out.println(type);</span><br><span class="line">    System.out.println(type <span class="keyword">instanceof</span> Class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。</p>
<p>同理，我们也可以像上面这样获取父接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123;</span><br><span class="line">        System.out.println(anInterface.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">for</span> (Type genericInterface : i.getClass().getGenericInterfaces()) &#123;</span><br><span class="line">        System.out.println(genericInterface.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a><strong>创建类对象</strong></h2><p>既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>newInstance()</code>方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String text)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为<code>newInstance()</code>只适用于默认无参构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当默认无参构造的权限不是<code>public</code>时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用<code>newInstance()</code>方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="string">&quot;what&#x27;s up&quot;</span>);</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String str)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用<code>getConstructor()</code>方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="string">&quot;what&#x27;s up&quot;</span>);</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String str)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);   <span class="comment">//修改访问权限</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;what&#x27;s up&quot;</span>);</span><br><span class="line">student.test();</span><br></pre></td></tr></table></figure>

<p>使用<code>getDeclaredConstructor()</code>方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）</p>
<hr>
<h2 id="调用类的方法"><a href="#调用类的方法" class="headerlink" title="调用类的方法"></a><strong>调用类的方法</strong></h2><p>我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们通过<code>forName(String)</code>来找到这个类并创建一个新的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();   <span class="comment">//创建出学生对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//通过方法名和形参类型获取类中的方法</span></span><br><span class="line"></span><br><span class="line">    method.invoke(instance, <span class="string">&quot;what&#x27;s up&quot;</span>);   <span class="comment">//通过Method对象的invoke方法来调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用<code>getMethod()</code>方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的<code>invoke()</code>方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。</p>
<p>我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。</p>
<p>同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将<code>test()</code>方法的权限修饰符改为private：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();   <span class="comment">//创建出学生对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//通过方法名和形参类型获取类中的方法</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    method.invoke(instance, <span class="string">&quot;what&#x27;s up&quot;</span>);   <span class="comment">//通过Method对象的invoke方法来调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//通过方法名和形参类型获取类中的方法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(method.getName());   <span class="comment">//获取方法名称</span></span><br><span class="line">    System.out.println(method.getReturnType());   <span class="comment">//获取返回值类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>, String[].class);</span><br></pre></td></tr></table></figure>

<p>反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。</p>
<hr>
<h2 id="修改类的属性"><a href="#修改类的属性" class="headerlink" title="修改类的属性"></a><strong>修改类的属性</strong></h2><p>我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过<code>getField()</code>方法来获取一个类定义的指定字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;i&quot;</span>);   <span class="comment">//获取类的成员字段i</span></span><br><span class="line">    field.set(instance, <span class="number">100</span>);   <span class="comment">//将类实例instance的成员字段i设置为100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    method.invoke(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在得到Field之后，我们就可以直接通过<code>set()</code>方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;i&quot;</span>);   <span class="comment">//获取类的成员字段i</span></span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(instance, <span class="number">100</span>);   <span class="comment">//将类实例instance的成员字段i设置为100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    method.invoke(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段<code>i</code>前面添加<code>final</code>关键字，我们再来看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Integer.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);  <span class="comment">//这里要获取Field类的modifiers字段进行修改</span></span><br><span class="line">    modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);  <span class="comment">//去除final标记</span></span><br><span class="line"></span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(i, <span class="number">100</span>);   <span class="comment">//强行设置值</span></span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    List&lt;String&gt; i = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ArrayList.class.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(i, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    i.add(<span class="string">&quot;测试&quot;</span>);   <span class="comment">//只添加一个元素</span></span><br><span class="line">    System.out.println(i.size());  <span class="comment">//大小直接变成11</span></span><br><span class="line">    i.remove(<span class="number">10</span>);   <span class="comment">//瞎移除都不带报错的，淦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！</p>
<p>再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！</p>
<hr>
<h2 id="自定义ClassLoader加载类"><a href="#自定义ClassLoader加载类" class="headerlink" title="自定义ClassLoader加载类"></a><strong>自定义ClassLoader加载类</strong></h2><p>我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(text+<span class="string">&quot; &gt; 我是测试方法！&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javac命令，手动编译一个.class文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java</span><br></pre></td></tr></table></figure>

<p>编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自己的ClassLoader</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b)&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);   <span class="comment">//调用protected方法，支持载入外部class文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Test.class&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[stream.available()];</span><br><span class="line">    stream.read(bytes);</span><br><span class="line">    Class&lt;?&gt; clazz = classLoader.defineClass(<span class="string">&quot;com.test.Test&quot;</span>, bytes);   <span class="comment">//类名必须和我们定义的保持一致</span></span><br><span class="line">    System.out.println(clazz.getName());   <span class="comment">//成功加载外部class文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//获取我们定义的test(String str)方法</span></span><br><span class="line">    method.invoke(obj, <span class="string">&quot;哥们这瓜多少钱一斤？&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试试看修改成员字段之后，再来调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;text&quot;</span>);   <span class="comment">//获取成员变量 String text;</span></span><br><span class="line">    field.set(obj, <span class="string">&quot;华强&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//获取我们定义的test(String str)方法</span></span><br><span class="line">    method.invoke(obj, <span class="string">&quot;哥们这瓜多少钱一斤？&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。</p>
<hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a><strong>注解</strong></h2><p>其实我们在之前就接触到注解了，比如<code>@Override</code>表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。</p>
<p>注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。</p>
<h3 id="预设注解"><a href="#预设注解" class="headerlink" title="预设注解"></a><strong>预设注解</strong></h3><p>JDK预设了以下注解，作用于代码：</p>
<ul>
<li>@Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）</li>
<li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a><strong>元注解</strong></h3><p>元注解是作用于注解上的注解，用于我们编写自定义的注解：</p>
<ul>
<li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented - 标记这些注解是否包含在用户文档中。</li>
<li>@Target - 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
<li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<p>看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看<code>@Override</code>是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解由<code>@Target</code>限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。<code>@Retention</code>表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个<code>@Retention</code>和1-n个<code>@Target</code>。</p>
<p>既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个最简单的注解就被我们创建了。</p>
<h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a><strong>注解的使用</strong></h3><p>我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test(test = &quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用default关键字来为这些属性指定默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;都看到这里了，给个三连吧！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(&quot;关注点了吗&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;)</span>   <span class="comment">//多个值时就使用花括号括起来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a><strong>反射获取注解</strong></h3><p>既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : clazz.getAnnotations()) &#123;</span><br><span class="line">        System.out.println(annotation.annotationType());   <span class="comment">//获取类型</span></span><br><span class="line">        System.out.println(annotation <span class="keyword">instanceof</span> Test);   <span class="comment">//直接判断是否为Test</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) annotation;</span><br><span class="line">        System.out.println(test.value());   <span class="comment">//获取我们在注解中写入的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="string">&quot;test&quot;</span>).getAnnotations()) &#123;</span><br><span class="line">        System.out.println(annotation.annotationType());   <span class="comment">//获取类型</span></span><br><span class="line">        System.out.println(annotation <span class="keyword">instanceof</span> Test);   <span class="comment">//直接判断是否为Test</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) annotation;</span><br><span class="line">        System.out.println(test.value());   <span class="comment">//获取我们在注解中写入的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是方法、类、还是字段，都可以使用<code>getAnnotations()</code>方法（还有几个同名的）来快速获取我们标记的注解。</p>
<p>所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lsely</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>


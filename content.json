{"meta":{"title":"lselyの博客","subtitle":"勤勤恳恳写代码，慵慵懒懒摆摆烂","description":"前进！不择手段的前进！","author":"lsely","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2022-12-11T07:57:34.000Z","updated":"2022-12-12T04:03:02.688Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"你进来干什么？想了解一下我？好吧. 性别：男年龄：■2体重：■5 kg身高：1■5 cm主力语言：C++,Java,平时写应用之类的就用这俩货;也会Python,但主要用来爬好康的。身份：程序员 * 学生爱好：写应用和打游戏"},{"title":"Flag","date":"2022-12-12T02:18:54.000Z","updated":"2022-12-12T02:24:28.207Z","comments":true,"path":"flag/index.html","permalink":"http://example.com/flag/index.html","excerpt":"","text":"写完Tbox++ 学习Android开发"},{"title":"标签","date":"2022-12-11T07:59:51.000Z","updated":"2022-12-12T00:42:09.986Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-11T08:00:45.000Z","updated":"2022-12-12T00:37:20.440Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Python+Tesseract实现图片文字识别","slug":"Python-Tesseract实现图片文字识别","date":"2022-12-12T02:44:03.000Z","updated":"2022-12-12T03:58:10.239Z","comments":true,"path":"2022/12/12/Python-Tesseract实现图片文字识别/","link":"","permalink":"http://example.com/2022/12/12/Python-Tesseract%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/","excerpt":"","text":"什么是OCR？OCR，全称Optical Character Recognition ，中文释义为光学字符识别，是指对一个包含文本信息的图片文件的识别，目前比较流行的OCR有tesseractOCR和cnOCR,在这篇文章中我们使用识别效果较好的tesseractOCR。 安装Tesseract-OCR和pytesseract首先我们要安装tesseract，这两个网址任选其一即可： Home · UB-Mannheim/tesseract Wiki (github.com) Index of /tesseract解释一下这些名称的含义，我们以最新版本v5.20举例：w64的w是指Windows系统，64则是指电脑CPU采用64位处理技术，setup就是安装包，后面的版本号很好理解了。但是如果版本号后面跟上alpha，dev的话就是指这个安装包为开发版或是预览版，大多数程序的开发板大多不稳定，所以这里我们就是用最新的v5.2.0稳定版安装包。 点击下载，下载完成后运行安装程序：选择语言，没有中文，只好选英文。 然后一直next，但是注意！在选择安装语言时这个Additional lauguage data千万不要全选，要不然下载过程特别慢，如果需要的话，只安装里面的 Chinese与English组件就行了。 接下来就比较简单了，直接next，等待安装完成即可。 安装完成后我们还得添加环境变量，打开自己安装tesseract的文件夹，复制路径： 回到桌面，右键此电脑：选择属性，点击高级系统设置，环境变量： 打开环境变量，双击用户变量的Path，新建变量： 把复制的路径粘贴进去，点确定，我们的环境配置就完成了。 验证安装win+r，输入cmd，输入 tesseract -v 再回车，如果出现了tesseract的版本信息就说明配置成功了。 为了在python中使用tesseract，我们需要安装pytesseract，直接在cmd中用pip安装就好了： 1pip install pytesseract （无视里面的黄色字体，是我电脑的问题，对安装什么的没有影响） 实现自动识别文字打开python编辑器，把这段代码复制进去： 1234567import pytesseractfrom PIL import Imagepytesseract.pytesseract.tesseract_cmd = &#x27;D://Tesseract-OCR//tesseract.exe&#x27; # 替换成你自己的tesseract安装路径text = pytesseract.image_to_string(Image.open(&#x27;D://input.png&#x27;)) # 替换成要识别的图片路径print(text) 用windows自带画图随便做个图： 运行输出为 Hello world ，完美。 怎么样，好玩吧？不仅这样，tesseract还可以识别中文！只不过得安装相应的库，这是下载链接： https://github.com/tesseract-ocr/tessdata/blob/main/chi_sim.traineddata下载下来中文训练包后，把包放到tessdata中就可以识别中文了。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"后端/Python","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Python/"},{"name":"人工智能","slug":"后端/Python/人工智能","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"2分钟速看Cookie","slug":"2分钟速看Cookie","date":"2022-12-11T14:02:46.000Z","updated":"2022-12-12T00:46:53.309Z","comments":true,"path":"2022/12/11/2分钟速看Cookie/","link":"","permalink":"http://example.com/2022/12/11/2%E5%88%86%E9%92%9F%E9%80%9F%E7%9C%8BCookie/","excerpt":"此文只是介绍Cookie一些基础知识和构成Cookie的组成部件，并不介绍用法。 Cookie是什么？Cookie , 在百度百科中的介绍是指”储存在用户本地终端上的数据”,用人话来说就类似于浏览器在本地的缓存，它是网站用来识别用户的一个文本。一般来说，在我们打开网站时，网站的Web服务器会为用户生成一个ID信息，可以说这就是用户的网络”身份证“，然后这个”身份证“就会保存到用户的电脑本地，以后如果用户再次登入这个网站，Web服务器就可以读取这个文本，就可以获取用户的各个信息了，这个过程也就是登录。","text":"此文只是介绍Cookie一些基础知识和构成Cookie的组成部件，并不介绍用法。 Cookie是什么？Cookie , 在百度百科中的介绍是指”储存在用户本地终端上的数据”,用人话来说就类似于浏览器在本地的缓存，它是网站用来识别用户的一个文本。一般来说，在我们打开网站时，网站的Web服务器会为用户生成一个ID信息，可以说这就是用户的网络”身份证“，然后这个”身份证“就会保存到用户的电脑本地，以后如果用户再次登入这个网站，Web服务器就可以读取这个文本，就可以获取用户的各个信息了，这个过程也就是登录。 Cookie的发送机制总体来说，每当我们第一次登录一个网站时，Web服务器就会发送一个Cookie到用户本地，在以后的登录中，用户本地的Cookie就会发送到Web服务器，从而验证自己的账户，用一张图来表示： Cookie的组成Cookie本质上还是一个文本数据，一般这个数据是经过加密的，由名称，值，还有几个用于控制Cookie使用范围或有效时间等量组成。 名称和值 Name/Value：Cookie的名称以及值。 有效期 Expires：Cookie的有效期。Expriers分为两种存储方式：会话性与持久性。会话性Cookie，保存在用户的内存中，会在推出浏览器时清空；而持久性Cookie会保存在用户的本地硬盘中，直至用户退出登录时才会失效 。说人话就是一个临时存储，一个长久存储。 使用范围 Domain：Cookie的使用于访问范围。 安全性 Secure：Cookie是否使用Https协议。 总结Cookie是网站用于识别用户身份，保存在用户本地上的数据（经过加密），由用户本地暂时或长久保存的文本数据，一般由名称，值，有效期，使用范围等组成。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Web","slug":"前端/Web","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小知识","slug":"小知识","permalink":"http://example.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"上千字干货带你深入了解C/C++动态规划","slug":"上千字干货带你深入了解C-C-动态规划","date":"2022-12-11T13:58:52.000Z","updated":"2022-12-12T01:23:23.581Z","comments":true,"path":"2022/12/11/上千字干货带你深入了解C-C-动态规划/","link":"","permalink":"http://example.com/2022/12/11/%E4%B8%8A%E5%8D%83%E5%AD%97%E5%B9%B2%E8%B4%A7%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3C-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"提醒：本文需读者具有以下C/C++基础： 循环结构，数组 函数 递归","text":"提醒：本文需读者具有以下C/C++基础： 循环结构，数组 函数 递归 动态规划的定义 动态规划（Dynamic Programming，简称DP），是一种通过把复杂问题分解为相对简单的子问题的方式求解最优策略的方法，可以有效的解决背包问题、资源分配问题、最短路径问题和复杂系统可靠性问题等求最优解策略问题。dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems. ——Wikipedia译文：一般这些子问题很相似，可以通过函数关系式递推出来。然后呢，动态规划就致力于解决每个子问题一次，减少重复计算,比如斐波那契数列就可以看做入门级的经典动态规划问题。 ——维基百科 说实话，我看我也头痛，拿来装杯不错，真理解还得靠自己啊！我给大家翻译翻译什么叫动态规划：动态规划，别看名字很高深，其实本质就是将复杂的问题化为简单的子问题，再将子问题化为更为简单的子问题，直至简单到不能再简单，一下就能给出答案的程度。就酱，很复杂的题就迎刃而解了。还有动态规划Plus版，就是将每一次子问题的答案保存下来，这样以后要用到时直接调用就行了，效率更上十层楼。也就是记忆化搜索。 什么？还不能理解？那就看这几个小剧场： A：1+2+3+4+5+6+7=28，那么1+2+3+4+5+6+7+8等于几？B：36。A：你是怎么算出来的？B：1+2+3+4+5+6+7=28，那么1+2+3+4+5+6+7+8=28+8=36. 这就是记忆化搜索。 核心思想我个人将其总结为一型三征，一型就是动态规划适合解决的问题的模型， 三征也就是三个特征：最优子结构，无后效性，记忆化搜索。 由于过于抽象，以下内容不要求全部背下，但一定要能够说出这三个性质中粗体部分。1.最优子结构如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。2.无后效性即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。3.记忆化搜索也称子问题重叠性质，子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，每次计算完一次子问题的答案，再将答案保存下来，在遇到重复的自问题时直接调用之前保存的答案，从而获得更高的效率。 解题步骤综上所述，那么基本的动态规划题目的解题步骤大体就是酱：1. 寻找最优子结构(状态表示)2. 写出状态转移方程(状态计算)3. 边界初始化 光说不练是假把式，我们先来看一道力扣极为经典的题目——斐波那契数列。 509.斐波那契数列 某网友：啊，这个我熟！肥波纳粹数列！我：emm….. 滚去练打字！ 本题链接： 509. 斐波那契数 - 力扣（LeetCode） 题目描述 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 哎呀，这时候可能有人要说了： 欸嘿嘿，这不简单，直接一个递归不就行了吗 于是他兴冲冲地写完代码： 1234567class Solution &#123;public: int fib(int n) &#123; if(n==0||n==1) return n; return fib(n-1)+fib(n-2); &#125;&#125;; 复制粘贴提交： 可以看到勉强虽然但是差不多通过了，但用时极其夸张，那这是为什么呢？别急，我们先来分析一下这个代码的运算过程。 代码分析我们设 n=5 时，来看一下程序的运算过程： 欸，你发现了什么？ fib (3)在计算过程中计算了两次 没错，上图中圈画的fib (3)在计算过程中计算了两次，而当我们把 n 设的更大，比如说 n=7。 会发现重复计算已经不是一次两次了，甚至是整个分支都存在重复。而计算越庞大，比如 n=1000,10000，重复计算也就越多，时间复杂度就十分恐怖了， 要不是力扣大大好，题目中设定了 0&lt;=n&lt;=30，也就是不可能超过30，这样做法肯定会超时。既然存在这么大的问题，那要怎么优化呢？ 优化方案没错，记忆化搜索，我们在前面讲过了，当子问题存在大量重复计算时，利用子问题重叠性质，就可以将子问题的答案记录下来，在需要用到时就直接调用，一劳永逸，很轻松就解决了重复计算的问题。 123456789101112131415class Solution &#123;public: int fib(int n) &#123; if (n &lt; 2) &#123; return n; &#125; int p = 0, q = 0, r = 1; for (int i = 2; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r; &#125;&#125;; 提交上去： 效率完爆递归算法。 练习题单做完这道题，是不是觉得自己又”行”了？ 那我可得好好挫挫你的锐气，动态规划难题多的是！来，收下这份大礼包（难度依次增加）： 70. 爬楼梯 - 力扣（LeetCode） 746. 使用最小花费爬楼梯 - 力扣（LeetCode） Loading Question… - 力扣（LeetCode） 5. 最长回文子串 - 力扣（LeetCode） 53. 最大子数组和 - 力扣（LeetCode） 95. 不同的二叉搜索树 II - 力扣（LeetCode） 213. 打家劫舍 II - 力扣（LeetCode） 32. 最长有效括号 - 力扣（LeetCode） 123. 买卖股票的最佳时机 III - 力扣（LeetCode） 689. 三个无重叠子数组的最大和 - 力扣（LeetCode） ——————本文完结撒花——————","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C/C++","slug":"后端/C-C","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/C-C/"},{"name":"算法","slug":"后端/C-C/算法","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/C-C/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"后端/Python","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Python/"},{"name":"人工智能","slug":"后端/Python/人工智能","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Web","slug":"前端/Web","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Web/"},{"name":"C/C++","slug":"后端/C-C","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/C-C/"},{"name":"算法","slug":"后端/C-C/算法","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/C-C/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小知识","slug":"小知识","permalink":"http://example.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}
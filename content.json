{"meta":{"title":"lselyの博客","subtitle":"勤勤恳恳写代码，慵慵懒懒摆摆烂","description":"前进！不择手段的前进！","author":"lsely","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2022-12-11T07:57:34.000Z","updated":"2022-12-11T08:22:43.939Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"你进来干什么？想了解一下我？好吧. 性别：男年龄：X2 岁体重：X5 kg身高：173 cm主力语言：C++,Java身份：程序员 * 学生爱好：写应用和打游戏"},{"title":"categories","date":"2022-12-11T08:00:45.000Z","updated":"2022-12-11T08:00:45.195Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-12-11T07:59:51.000Z","updated":"2022-12-11T07:59:51.668Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 学习笔记","slug":"Java 学习笔记 2372099853a64865b128945de517dfb4","date":"2022-12-11T07:57:34.000Z","updated":"2022-12-11T09:58:41.980Z","comments":true,"path":"2022/12/11/Java 学习笔记 2372099853a64865b128945de517dfb4/","link":"","permalink":"http://example.com/2022/12/11/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202372099853a64865b128945de517dfb4/","excerpt":"Java基础语法（面向过程）在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！","text":"Java基础语法（面向过程）在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！ 变量和关键字变量变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）： 123int a = 10;a = 20;a = 30; 我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解） 变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C++– Java是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！） 定义一个变量的格式如下： 12[类型] [标识符(名字)] = [初始值(可选)]int a = 10; 注意：标识符不能为以下内容： 标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。 大小写敏感！ 不能有空格、@、#、+、-、/ 等符号 应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头 不可以是 true 和 false 不能与Java语言的关键字重名 关键字包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！ 常量常量就是无法修改值的变量，常量的值，只能定义一次： 12final int a = 10;a = 10; //报错！ 常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！） 这只是final关键字的第一个用法，后面还会有更多的用法。 注释养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释： 12345678//我是单行注释/*** 我是* 多行注释*///TODO 待做标记 基本数据类型Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。 这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了） 计算机中的二进制表示在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。 十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0 现在有4个bit位，最大能够表示多大的数字呢？ 最小：0000 =&gt; 0 最大：1111 =&gt; 2^3+2^2+2^1+2^0 =&gt; 8 + 4 + 2 + 1 = 15 在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）： 最小：1111 =&gt; -(2^2+2^1+2^0) =&gt; -7 最大：0111 =&gt; +(2^2+2^1+2^0) =&gt; +7 =&gt; 7 现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。 计算机中的加减法原码虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例： 1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！） 我们得创造一种更好的表示方式！于是我们引入了反码： 反码 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法： 1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！） 思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？ 0既不是正数也不是负数，那么显然这样的表示依然不够合理！ 补码根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下： 正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算： 1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！） 所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！） 以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解 整数类型整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。 在Java中，整数类型包括以下几个： byte 字节型 （8个bit，也就是1个字节）范围：-128~+127 short 短整形（16个bit，也就是2个字节）范围：-32768~+32767 int 整形（32个bit，也就是4个字节）最常用的类型！ long 长整形（64个bit，也就是8个字节）最后需要添加l或L long都装不下怎么办？BigInteger！ 数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例： 0111 + 0001 = 1000 =&gt; -8（你没看错，就是这样！） 整数还能使用8进制、16进制表示： 十进制为15 = 八进制表示为017 = 十六进制表示为 0xF = 二进制表示 1111 (代码里面不能使用二进制！) 字符类型和字符串在Java中，存在字符类型，它能够代表一个字符： char 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535 使用Unicode表示就是：\\u0000 ~ \\uffff 字符要用单引号扩起来！比如 char c = ‘淦’; 字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符&#39;A&#39;的ASCII码就是数字65，所以，char类型其实可以转换为上面的整数类型。 Java的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名） 既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解） String就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。 字符串用双引号括起来！比如：String str = “一日三餐没烦恼”; 小数类型小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些： float 单精度浮点型 （32bit，4字节） double 双精度浮点型（64bit，8字节） 思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的： 根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：V = (-1)^S × M × 2^E（1）(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）（3）2^E 表示指数位。（用于移动小数点） 比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。 思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！ 布尔类型布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。 类型转换隐式类型转换隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下： byte→short(char)→int→long→float→double 问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！ 所以，如下的代码就能够正常运行： 123456789byte b = 9;short s = b;int i = s;long l = i;float f = l;double d = f;System.out.println(d);//输出 9.0 显示类型转换显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。 12345int i = 128;byte b = (byte)i;System.out.println(b);//输出 -128 为什么结果是-128？精度丢失了！ int 类型的128表示：00000000 00000000 00000000 10000000 byte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 =&gt; -128 数据类型自动提升在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型： 123byte b = 105;b = b + 1; //报错！System.out.println(b); 这个特性是由 Java虚拟机规范 定义的，也是为了提高运行的效率。其他的特性还有： 如果一个操作数是long型，计算结果就是long型 如果一个操作数是float型，计算结果就是float型 如果一个操作数是double型，计算结果就是double型 运算符赋值和算术运算符赋值运算符=是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如： 123int a = 10;int b = 1 + 8;int c = 5 * 5; 算术运算符也就是我们在小学阶段学习的+ - * / %，分别代表加减乘除还有取余，例如： 1234int a = 2;int b = 3;int c = a * b;//结果为6 需要注意的是，+还可以用作字符串连接符使用： 1System.out.println(&quot;lbw&quot; + &quot;nb&quot;); //lbwnb 当然，字符串可以直接连接其他类型，但是会全部当做字符串处理： 12int a = 7, b = 15;System.out.println(&quot;lbw&quot; + a + b); //lbw715 算术运算符还包括++和--也就是自增和自减，以自增为例： 123int a = 10;a++;System.out.println(a); //输出为11 自增自减运算符放在变量的前后的返回值是有区别的： 123int a = 10;System.out.println(a++); //10 （先返回值，再自增）System.out.println(a); //11 123int a = 10;System.out.println(++a); //11 （先自增，再返回值）System.out.println(a); //11 123int a = 10;int b = 2;System.out.println(b+++a++); //猜猜看结果是多少 为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括+=、-=、/=、*=、%=，和自增自减类似，先执行运算，再返回结果，同时自身改变： 12int a = 10;System.out.println(a += 2); //等价于 a = a + 2 关系运算符关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括： 12&gt; &lt; == //大于小于等于&gt;= &lt;= != //大于等于，小于等于，不等于 关系运算符一般只用于基本类型的比较，运算结果只能是boolean： 12345int a = 10;int b = 2;boolean x = a &gt; b;System.out.println(x);//结果为 true 逻辑运算符逻辑运算符两边只能是boolean类型或是关系/逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括： 123&amp;&amp; //与运算，要求两边同时为true才能返回true|| //或运算，要求两边至少要有一个为true才能返回true! //非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转 实际案例来看看： 1234int a = 10;int b = 2;boolean x = a &gt; b &amp;&amp; a &lt; b; //怎么可能同时满足呢System.out.println(x); //false 1234int a = 10;int b = 2;boolean x = a &gt; b || a &lt;= b; //一定有一个满足！System.out.println(x); //true 1234int a = 10;int b = 2;boolean x = !(a &gt; b); //对结果进行反转，本来应该是trueSystem.out.println(x); //false 位运算符1234&amp; //按位与，注意，返回的是运算后的同类型值，不是boolean！| //按位或^ //按位异或 0 ^ 0 = 0~ //按位非 按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例： 0101 &amp; 0100 = 0100 （只有同时为1对应位才得1） 12int a = 7, b = 15;System.out.println(a &amp; b); //结果为7 三目运算符三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下： 123int a = 7, b = 15;String str = a &gt; b ? &quot;行&quot; : &quot;不行&quot;; // 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值System.out.println(&quot;汉堡做的行不行？&quot;+str); //汉堡做的行不行？不行 理解三目运算符，就很容易理解后面的if-else语句了。 流程控制我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！ 选择结构选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。 if语句就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句： 123456if(判断条件)&#123; //判断成功执行的内容&#125;else&#123; //判断失败执行的内容&#125;//if的内容执行完成后，后面的内容正常执行 其中，else语句不是必须的。 现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断： 1234567if(判断条件1)&#123; //判断成功执行的内容&#125;else if(判断条件2)&#123; //再次判断，如果判断成功执行的内容&#125;else&#123; //上面的都没成功，只能走这里&#125; 同样，else语句不是必须的。 现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了： 12345678if(判断条件1)&#123; //前提是判断条件1要成功才能进来！ if(判断条件2)&#123; //判断成功执行的内容 &#125;else&#123; //判断失败执行的内容 &#125;&#125; switch语句我们不难发现，虽然else-if能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？ 1234567891011switch(判断主体)&#123; case 值1: //运行xxx break; //break用于跳出switch语句，不添加会导致程序继续向下运行！ case 值2: //运行xxx break; case 值3: //运行xxx break;&#125; 在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！ 为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！ 循环结构小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？ for语句for语句是比较灵活的循环控制语句，一个for语句的定义如下： 1234for(初始条件;循环条件;更新)&#123; //循环执行的内容&#125;//循环结束后，继续执行 初始条件：循环开始时的条件，一般用于定义控制循环的变量。 循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。 更新：每轮循环结束后都会执行的内容，一般写增量表达式。 初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！ 123for(int i = 0;i &lt; 520;i++)&#123; System.out.println(&quot;我爱你&quot;);&#125; 123for(;;)&#123; //这里的内容将会永远地进行下去！&#125; 增强for循环在数组时再讲解！ while循环while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！ 123while(循环条件)&#123; //循环执行的内容&#125; 和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句： 123do&#123; //执行内容&#125;while(循环条件); 一定会先执行do里面的内容，再做判断！ 思考： 123456789for(;;)&#123;&#125;while(true)&#123;&#125;//它们的性能谁更高？ 面向过程编程实战（基础+算法）打印九九乘法表简单：将九九乘法表打印到控制台。 求1000以内的水仙花数中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 = 1^3 + 5^3 + 3^3 青蛙跳台阶问题困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。 动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推 不对啊，别的教程都讲了数组、方法，怎么我们还没讲就进入面向对象了呢？ 数组在Java中，并非基本类型，数组是编程不可见的对象类型，学习了面向对象再来理解，会更加容易！ 方法在Java中是类具有的属性，所以，在了解了对象类型之后，再来了解方法，就更加简单了！ Java对象和多态 （面向对象）面向对象基础面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。 1234Scanner sc = new Scanner(System.in);String str = sc.nextLine();System.out.println(&quot;你输入了：&quot;+str);sc.close(); 所有的对象，都需要通过new关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！ 不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论） 对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！ 类的基本结构为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。 成员变量在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过.来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！ 12345678910public class Test &#123; int age; String name;&#125;public static void main(String[] args) &#123; Test test = new Test(); test.name = &quot;奥利给&quot;; System.out.println(test.name);&#125; 成员变量默认带有初始值，也可以自己定义初始值。 成员方法我们之前的学习中接触过方法(Method)吗？主方法！ 123public static void main(String[] args) &#123; //Body&#125; 方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。 方法的定义和使用在类中，我们可以定义自己的方法，格式如下： 1234[返回值类型] 方法名称([参数])&#123; //方法体 return 结果;&#125; 返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值 方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！ 参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法 方法体：方法具体要干的事情 结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return） 非void方法中，return关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！ 1234567int test(int a)&#123; if(a &gt; 0)&#123; //缺少retrun语句！ &#125;else&#123; return 0; &#125;&#125; return也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！ 123456void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; if(i == 1) return; //在循环内返回了！和break区别？ &#125; System.out.println(&quot;淦&quot;); //还会到这里吗？&#125; 传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！ 12345678910111213public static void main(String[] args) &#123; int a = 10, b = 20; new Test().swap(a, b); System.out.println(&quot;a=&quot;+a+&quot;, b=&quot;+b);&#125;public class Test&#123; void swap(int a, int b)&#123; //传递的仅仅是值而已！ int temp = a; a = b; b = temp; &#125;&#125; 传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针） 1234567891011121314151617public class B&#123; String name;&#125;public class A&#123; void test(B b)&#123; //传递的是对象的引用，而不是值 System.out.println(b.name); &#125;&#125;public static void main(String[] args) &#123; int a = 10, b = 20; B b = new B(); b.name = &quot;lbw&quot;; new A().test(b); System.out.println(&quot;a=&quot;+a+&quot;, b=&quot;+b);&#125; 方法之间可以相互调用 1234567void a()&#123; //xxxx&#125;void b()&#123; a();&#125; 当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！） 123int a()&#123; return a();&#125; 成员方法和成员变量一样，是属于对象的，只能通过对象去调用！ 对象设计练习 学生应该具有以下属性：名字、年龄 学生应该具有以下行为：学习、运动、说话 方法的重载一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！ 1234567891011121314151617public class Test &#123; int a()&#123; //原本的方法 return 1; &#125; int a(int i)&#123; //ok，形参不同 return i; &#125; void a(byte i)&#123; //ok，返回类型和形参都不同 &#125; void a()&#123; //错误，仅返回值类型名称不同不能重载 &#125;&#125; 现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑： 123456789public class Test &#123; int sum(int a, int b)&#123; //只有int支持，不灵活！ return a+b; &#125; double sum(double a, double b)&#123; //重写一个double类型的，就支持小数计算了 return a+b; &#125;&#125; 现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？ 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; void a(int i)&#123; System.out.println(&quot;调用了int&quot;); &#125; void a(short i)&#123; System.out.println(&quot;调用了short&quot;); &#125; void a(long i)&#123; System.out.println(&quot;调用了long&quot;); &#125; void a(char i)&#123; System.out.println(&quot;调用了char&quot;); &#125; void a(double i)&#123; System.out.println(&quot;调用了double&quot;); &#125; void a(float i)&#123; System.out.println(&quot;调用了float&quot;); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.a(1); //直接输入整数 test.a(1.0); //直接输入小数 short s = 2; test.a(s); //会对号入座吗？ test.a(1.0F); &#125;&#125; 构造方法构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。 1234567//反编译结果package com.test;public class Test &#123; public Test() &#123; //即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的 &#125;&#125; 反编译其实就是把我们编译好的class文件变回Java源代码。 12Test test = new Test(); //实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的// new + 你想要使用的构造方法 这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！ 类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！ 一般最常用的就是给成员属性赋初始值： 1234567public class Student &#123; String name; Student()&#123; name = &quot;伞兵一号&quot;; &#125;&#125; 我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字 123456789public class Student &#123; String name; Student(String name)&#123; //形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！ this.name = name; //通过this指代当前的对象属性，this就代表当前对象 &#125;&#125;//idea 右键快速生成！ 注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。 在我们定义了新的有参构造之后，默认的无参构造会被覆盖！ 1//反编译后依然只有我们定义的有参构造！ 如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。 1234567891011public class Student &#123; String name; Student()&#123; &#125; Student(String name)&#123; this.name = name; &#125;&#125; 成员变量的初始化始终在构造方法执行之前 1234567891011public class Student &#123; String a = &quot;sadasa&quot;; Student()&#123; System.out.println(a); &#125; public static void main(String[] args) &#123; Student s = new Student(); &#125;&#125; 静态变量和静态方法静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。 12345678910public class Student &#123; static int a;&#125;public static void main(String[] args) &#123; Student s1 = new Student(); s1.a = 10; Student s2 = new Student(); System.out.println(s2.a);&#125; 不推荐使用对象来调用，被标记为静态的内容，可以直接通过类名.xxx的形式访问 1234public static void main(String[] args) &#123; Student.a = 10; System.out.println(Student.a);&#125; 简述类加载机制类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类： 访问类的静态变量，或者为静态变量赋值 new 创建类的实例（隐式加载） 调用类的静态方法 子类初始化时 其他的情况会在讲到反射时介绍 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。 123456789101112public class Student &#123; static int a = test(); //直接调用静态方法，只能调用静态方法 Student()&#123; System.out.println(&quot;构造类对象&quot;); &#125; static int test()&#123; //静态方法刚加载时就有了 System.out.println(&quot;初始化变量a&quot;); return 1; &#125;&#125; 思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？ 1234567891011public class Student &#123; static int a = test(); static int test()&#123; return a; &#125; public static void main(String[] args) &#123; System.out.println(Student.a); &#125;&#125; 定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0 代码块和静态代码块代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作） 123456789public class Student &#123; &#123; System.out.println(&quot;我是代码块&quot;); &#125; Student()&#123; System.out.println(&quot;我是构造方法&quot;); &#125;&#125; 静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用； 1234567891011public class Student &#123; static int a; static &#123; a = 10; &#125; public static void main(String[] args) &#123; System.out.println(Student.a); &#125;&#125; String和StringBuilder类字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例) String的对象直接支持使用+或+=运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！） 123String a = &quot;dasdsa&quot;, b = &quot;dasdasdsa&quot;;String l = a+b;System.out.println(l); 大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！） 1String result=&quot;String&quot;+&quot;and&quot;; //会被优化成一句！ 1234String str1=&quot;String&quot;;String str2=&quot;and&quot;;String result=str1+str2;//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定 1234String str1=&quot;String&quot;;String str2=&quot;and&quot;;String result=(new StringBuilder(String.valueOf(str1))).append(str2).toString();//使用StringBuilder，会采用类似于第一种实现，显然会更快！ StringBuilder也是一个类，但是它能够存储可变长度的字符串！ 1234567StringBuilder builder = new StringBuilder();builder .append(&quot;a&quot;) .append(&quot;bc&quot;) .append(&quot;d&quot;); //链式调用String str = builder.toString();System.out.println(str); 包和访问控制包声明和导入包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！ 12345package com.test;public class Test&#123;&#125; 包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。 一般包按照个人或是公司域名的规则倒过来写 顶级域名.一级域名.二级域名 com.java.xxxx 如果需要使用其他包里面的类，那么我们需要import（类似于C/C++中的include） 1import com.test.Student; 也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！） 1import com.test.* Java默认为我们导入了以下的包，不需要去声明 1import java.lang.* 静态导入静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。 1234567import static com.test.ui.Student.test;public class Main &#123; public static void main(String[] args) &#123; test(); &#125;&#125; 静态导入不会进行类的初始化！ 访问控制Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。 权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！ 12345678public class Student &#123; private int a = 10; //具有私有访问权限，只能类内部访问&#125;public static void main(String[] args) &#123; Student s = new Student(); System.out.println(s.a); //还可以访问吗？&#125; 和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！ 1234567// Student.javapublic class Student &#123;&#125;class Test&#123; //不能添加权限修饰符！只能是default&#125; 数组类型假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？ https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&amp;refer=http%3A%2F%2Fimgs.itxueyuan.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632192902&amp;t=7a6d67fc01d0e3ea7816adf951c49605 我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！ 12int[] arr = new int[10]; //需要new关键字来创建！String[] arr2 = new String[10]; 数组本身也是类（编程不可见，C++写的），不是基本数据类型！ 123int[] arr = new int[10];System.out.println(arr.length); //数组有成员变量！System.out.println(arr.toString()); //数组有成员方法！ 一维数组一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下： 12345类型[] 变量名称 = new 类型[数组大小];类型 变量名称n = new 类型[数组大小]; //支持C语言样式，但不推荐！类型[] 变量名称 = new 类型[]&#123;...&#125;; //静态初始化（直接指定值和大小）类型[] 变量名称 = &#123;...&#125;; //同上，但是只能在定义时赋值 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问： 1234int[] arr = new int[10];arr[0] = 626;System.out.println(arr[0]);System.out.println(arr[1]); 我们可以通过数组变量名称.length来获取当前数组长度： 12int[] arr = new int[]&#123;1, 2, 3&#125;;System.out.println(arr.length); //打印length成员变量的值 数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！ 12345String[] arr = new String[10];System.out.println(arr[10]); //出现异常！//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11// at com.test.Application.main(Application.java:7) 思考：能不能直接修改length的值来实现动态扩容呢？ 12int[] arr = new int[]&#123;1, 2, 3&#125;;arr.length = 10; 数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身 123456789public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, 2, 3&#125;; test(arr); System.out.println(arr[0]);&#125;private static void test(int[] arr)&#123; arr[0] = 2934;&#125; 数组的遍历如果我们想要快速打印数组中的每一个元素，又怎么办呢？ 传统for循环我们很容易就联想到for循环 1234int[] arr = new int[]&#123;1, 2, 3&#125;;for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; foreach传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？ 1234int[] arr = new int[]&#123;1, 2, 3&#125;;for (int i : arr) &#123; System.out.println(i);&#125; foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。 二维数组二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。 https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&amp;refer=http%3A%2F%2Ffile.elecfans.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632204192&amp;t=52381354d190d09899776f9bb868ef3e 12345//三行两列int[][] arr = &#123; &#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;System.out.println(arr[2][1]); 二维数组的遍历同一维数组一样，只不过需要嵌套循环！ 12345678int[][] arr = new int[][]&#123; &#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; System.out.println(arr[i][j]); &#125;&#125; 多维数组不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。 可变长参数可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量 1234567public static void main(String[] args) &#123; test(&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;); //可变长，最后都会被自动封装成一个数组&#125;private static void test(String... test)&#123; System.out.println(test[0]); //其实参数就是一个数组&#125; 由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！ 实战：三大基本排序算法现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？ 1int[] arr = &#123;8, 5, 0, 1, 4, 9, 2, 3, 6, 7&#125;; 排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法： 冒泡排序 冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。 插入排序 插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！ https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&amp;refer=http%3A%2F%2Fimg1.jjhgame.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632208529&amp;t=f3fb9be4dce91c6364f5ec4f9faafc94 选择排序 选择排序其实就是每次都选择当前数组中最大的数排到最前面！ 封装、继承和多态封装、继承和多态是面向对象编程的三大特性。 封装封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。 设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？ 1234567891011121314151617public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125;&#125; 也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。 1234public void setName(String name) &#123; if(name.contains(&quot;小&quot;)) return; this.name = name;&#125; 单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！ 封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。 封装就是通过访问权限控制来实现的。 继承继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。 现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法： 123456789101112131415161718192021public class SportsStudent extends Student&#123; //通过extends关键字来继承父类 public SportsStudent(String name, int age) &#123; super(name, age); //必须先通过super关键字（指代父类），实现父类的构造方法！ &#125; public void exercise()&#123; System.out.println(&quot;我超勇的！&quot;); &#125;&#125;public class ArtStudent extends Student&#123; public ArtStudent(String name, int age) &#123; super(name, age); &#125; public void art()&#123; System.out.println(&quot;随手画个毕加索！&quot;); &#125;&#125; 子类具有父类的全部属性，protected可见但外部无法使用（包括private属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！ 每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用super()，如果父类使用的是默认构造方法，那么子类不用手动指明。 所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如： 123456public static void main(String[] args) &#123;Object obj = new Object;System.out.println(obj.hashCode()); //求对象的hashcode，默认是对象的内存地址System.out.println(obj.equals(obj)); //比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==System.out.println(obj.toString()); //将对象转换为字符串，默认生成对象的类名称+hashcode&#125; 关于Object类的其他方法，我们会在Java多线程中再来提及。 多态多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！ 方法的重写我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！ 12345678910//父类中的studypublic void study()&#123; System.out.println(&quot;学习&quot;);&#125;//子类中的study@Override //声明这个方法是重写的，但是可以不要，我们现阶段不接触public void study()&#123; System.out.println(&quot;给你看点好康的&quot;);&#125; 再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！ 1234public static void main(String[] args) &#123; SportsStudent student = new SportsStudent(&quot;lbw&quot;, 20); student.study(); //输出子类定义的内容&#125; 思考：静态方法能被重写吗？ 当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？ 1234public void study()&#123; super.study(); System.out.println(&quot;给你看点好康的&quot;);&#125; 同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量 12345public void setTest(int test)&#123; test = 1; this.test = 1; super.test = 1;&#125; 再谈类型转换我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型： 12Student student = new SportsStudent(&quot;lbw&quot;, 20); //父类变量引用子类实例student.study(); //得到依然是具体实现的结果，而不是当前类型的结果 我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型： 12345Student student = new SportsStudent(&quot;lbw&quot;, 20); //是由SportsStudent进行实现的//... do something...SportsStudent ps = (SportsStudent)student; //让它变成一个具体的子类ps.sport(); //调用具体实现类的方法 这样的类型转换称为向下转型。 instanceof关键字那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！ 123456789private static void test(Student student)&#123; if (student instanceof SportsStudent)&#123; SportsStudent sportsStudent = (SportsStudent) student; sportsStudent.sport(); &#125;else if (student instanceof ArtStudent)&#123; ArtStudent artStudent = (ArtStudent) student; artStudent.art(); &#125;&#125; 通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！ 思考：student instanceof Student的结果是什么？ 再谈final关键字我们目前只知道final关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？ 123public final class Student &#123; //类被声明为终态，那么它还能被继承吗&#125; 类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？ 123public final void study()&#123; //还能重写吗 System.out.println(&quot;学习&quot;);&#125; 如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！ 1234567private final String name; //引用类型不允许再指向其他对象private final int age; //基本类型值不允许发生改变public Student(String name, int age) &#123; this.name = name; this.age = age;&#125; 学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！ 抽象类类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！ 123public abstract class Student &#123; //抽象类 public abstract void test(); //抽象方法&#125; 通过使用abstract关键字来表明一个类是一个抽象类，抽象类可以使用abstract关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是必须由子类实现（除非子类也是一个抽象类）！ 抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！ 12345Student s = new Student()&#123; //只能直接创建带实现的匿名内部类！ public void test()&#123; &#125;&#125; 因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确： 123public void study()&#123; //现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！ System.out.println(&quot;给你看点好康的&quot;);&#125; 接口接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现） 123public interface Eat &#123; void eat();&#125; 通过使用interface关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含public权限的抽象方法！（Java8以后可以有默认实现）我们可以通过声明default关键字来给抽象方法一个默认实现： 12345public interface Eat &#123; default void eat()&#123; //do something... &#125;&#125; 接口中定义的变量，默认为public static final 1234public interface Eat &#123; int a = 1; void eat();&#125; 一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！ 123456public class SportsStudent extends Student implements Eat, ...&#123; @Override public void eat() &#123; &#125;&#125; 类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！ 实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！ 内部类类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！ 成员内部类我们的类中可以在嵌套一个类： 12345public class Test &#123; class Inner&#123; //类中定义的一个内部类 &#125;&#125; 成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！ 1234public static void main(String[] args) &#123; Test test = new Test(); Test.Inner inner = test.new Inner(); //写法有那么一丝怪异，但是没毛病！&#125; 静态内部类静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过类名.去访问: 123456789public class Test &#123; static class Inner&#123; &#125;&#125;public static void main(String[] args) &#123; Test.Inner inner = new Test.Inner(); //不用再创建外部类对象了！&#125; 局部内部类对，你没猜错，就是和局部变量一样哒~ 123456789public class Test &#123; public void test()&#123; class Inner&#123; &#125; Inner inner = new Inner(); &#125;&#125; 反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！ 匿名内部类匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现： 12345678public static void main(String[] args) &#123; Eat eat = new Eat() &#123; @Override public void eat() &#123; //DO something... &#125; &#125;; &#125; 我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！ lambda表达式读作λ表达式，它其实就是我们接口匿名实现的简化，比如说： 123456789101112public static void main(String[] args) &#123; Eat eat = new Eat() &#123; @Override public void eat() &#123; //DO something... &#125; &#125;; &#125;public static void main(String[] args) &#123; Eat eat = () -&gt; &#123;&#125;; //等价于上述内容 &#125; lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！ 为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer 枚举类假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态： 123456789101112131415public class Student &#123; private final String name; private final int age; private String status; //... public void setStatus(String status) &#123; this.status = status; &#125; public String getStatus() &#123; return status; &#125;&#125; 但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！ 有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！ 123public enum Status &#123; RUNNING, STUDY, SLEEP //直接写每个状态的名字即可，分号可以不打，但是推荐打上&#125; 使用枚举类也非常方便，我们只需要直接访问即可 123456789101112131415161718192021public class Student &#123; private final String name; private final int age; private Status status; //... public void setStatus(Status status) &#123; //不再是String，而是我们指定的枚举类型 this.status = status; &#125; public Status getStatus() &#123; return status; &#125;&#125;public static void main(String[] args) &#123; Student student = new Student(&quot;小明&quot;, 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus());&#125; 枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量！ 123456789// Compiled from &quot;Status.java&quot;public final class com.test.Status extends java.lang.Enum&lt;com.test.Status&gt; &#123; public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static &#123;&#125;;&#125; 既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法 123456789101112131415161718public enum Status &#123; RUNNING(&quot;睡觉&quot;), STUDY(&quot;学习&quot;), SLEEP(&quot;睡觉&quot;); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！） private final String name; //枚举的成员变量 Status(String name)&#123; //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; &#125; public String getName() &#123; //获取封装的成员变量 return name; &#125;&#125;public static void main(String[] args) &#123; Student student = new Student(&quot;小明&quot;, 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName());&#125; 枚举类还自带一些继承下来的实用方法 12Status.valueOf(&quot;&quot;) //将名称相同的字符串转换为枚举Status.values() //快速获取所有的枚举 基本类型包装类Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！ 我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ byte -&gt; Byte boolean -&gt; Boolean short -&gt; Short char -&gt; Character int -&gt; Integer long -&gt; Long float -&gt; Float double -&gt; Double 包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想） 12345private final int value; //Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作public Integer(int value) &#123; this.value = value;&#125; 现在我们操作的就是Integer对象而不是一个int基本类型了！ 1234public static void main(String[] args) &#123; Integer i = 1; //包装类型可以直接接收对应类型的数据，并变为一个对象！ System.out.println(i + i); //包装类型可以直接被当做一个基本类型进行操作！&#125; 自动装箱和拆箱那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制 12Integer i = 1; //其实这里只是简写了而已Integer i = Integer.valueOf(1); //编译后真正的样子 调用valueOf来生成一个Integer对象！ 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考） return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); //返回一个新创建好的对象&#125; 而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱： 1234567public static void main(String[] args) &#123; Integer i = Integer.valueOf(1); int a = i; //简写 int a = i.intValue(); //编译后实际的代码 long c = i.longValue(); //其他类型也有！&#125; 既然现在是包装类型了，那么我们还能使用==来判断两个数是否相等吗？ 1234567public static void main(String[] args) &#123; Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1 == i2); //实际上判断是两个对象是否为同一个对象（内存地址是否相同） System.out.println(i1.equals(i2)); //这个才是真正的值判断！&#125; 注意IntegerCache带来的影响！ 思考：下面这种情况结果会是什么？ 123456public static void main(String[] args) &#123; Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1+1 == i2+1);&#125; 在集合类的学习中，我们还会继续用到我们的包装类型！ 面向对象编程实战虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和： 1234567891011public static void main(String[] args) &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; //for循环暴力求解，简单，但是效率似乎低了一些 sum += i; &#125; System.out.println(sum);&#125;public static void main(String[] args) &#123; System.out.println((1 + 100) * 50); //高斯求和公式，利用数学，瞬间计算结果！&#125; 说到最后，其实数学和逻辑思维才是解决问题的最终办法！ 对象设计（面向对象、多态运用） 设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。 设计设计一个接口考试，只有老师和学生会考试。 设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。 二分搜索（搜索算法）现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回-1即可。 12345int[] arr = new int[]&#123;1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26&#125;; //测试用例private static int test(int[] arr, int target)&#123; //请在这里实现搜索算法&#125; 快速排序（排序算法、递归分治）（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用分治法来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。 快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！ 0/1背包问题（回溯法、剪枝/动态规划优化）给定 n件物品，每一个物品的重量为 w[n]，每个物品的价值为 v[n]。现挑选物品放入背包中，假定背包能承受的最大重量为 capacity，求装入物品的最大价值是多少? 123int[] w = &#123;2, 3, 4, 5&#125;;int[] v = &#123;3, 4, 5, 6&#125;;int capacity = 8; Java异常机制在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ 1234567891011public static void main(String[] args) &#123; test(1, 0); //当b为0的时候，还能正常运行吗？&#125;private static int test(int a, int b)&#123; return a/b; //没有任何的判断而是直接做计算&#125;Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at com.test.Application.test(Application.java:9) at com.test.Application.main(Application.java:5) 当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！ 异常我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ 运行时异常异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自RuntimeException。 编译时异常异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。 12File file = new File(&quot;my.txt&quot;);file.createNewFile(); //要调用此方法，首先需要处理异常 错误错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了） 1int[] arr = new int[Integer.MAX_VALUE]; //能创建如此之大的数组吗？ 运行后得到以下内容： 12Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit at com.test.Main.main(Main.java:14) 错误都继承自Error类，一般情况下，程序中只能处理异常，错误是很难进行处理的，Error和Execption都继承自Throwable类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行： 12int[] arr = new int[Integer.MAX_VALUE];System.out.println(&quot;lbwnb&quot;); //还能正常打印吗？ 异常的处理当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： 123int[] arr = new int[5];arr[5] = 1; //我们需要处理这种情况，保证后面的代码正常运行！System.out.println(&quot;lbwnb&quot;); 我们可以使用try和catch语句块来处理： 12345678int[] arr = new int[5];try&#123; //在try块中运行代码 arr[5] = 1; //当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象&#125;catch (ArrayIndexOutOfBoundsException e)&#123; //捕获的异常类型 System.out.println(&quot;程序运行出现异常！&quot;); //出现异常时执行&#125;//后面的代码会正常运行System.out.println(&quot;lbwnb&quot;); 当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。 我们可以通过使用e.printStackTrace()来打印栈追踪信息，定位我们的异常出现位置： 1234java.lang.ArrayIndexOutOfBoundsException: 5 at com.test.Main.main(Main.java:7) //Main类的第7行出现问题程序运行出现异常！lbwnb 运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理： 123456File file = new File(&quot;my.txt&quot;);try &#123; file.createNewFile();&#125; catch (IOException e) &#123; //捕获声明的异常类型 e.printStackTrace();&#125; 可以捕获到类型不止是Exception的子类，只要是继承自Throwalbe的类，都能被捕获，也就是说，Error也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现Error应该从问题的根源去解决。 异常的抛出当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题： 123456789101112public static void main(String[] args) &#123; try &#123; test(1, 0); &#125; catch (Exception e) &#123; //捕获方法中会出现的异常 e.printStackTrace(); &#125; &#125; private static int test(int a, int b) throws Exception &#123; //声明抛出的异常类型 if(b == 0) throw new Exception(&quot;0不能做除数！&quot;); //创建异常对象并抛出异常 return a/b; //抛出异常会终止代码运行 &#125; 通过throw关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。 如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息） 如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明throws来继续交给上一级处理。 12345678public static void main(String[] args) throws Exception &#123; //出现异常就再往上抛，而不是在此方法内处理 test(1, 0);&#125;private static int test(int a, int b) throws Exception &#123; //声明抛出的异常类型 if(b == 0) throw new Exception(&quot;0不能做除数！&quot;); //创建异常对象并抛出异常 return a/b;&#125; 当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息） 异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获： 1234567891011121314151617public static void main(String[] args) throws Exception &#123; try&#123; test(1, 0); &#125;catch (Exception e)&#123; System.out.println(&quot;外层&quot;); &#125; &#125; private static int test(int a, int b)&#123; try&#123; if(b == 0) throw new Exception(&quot;0不能做除数！&quot;); &#125;catch (Exception e)&#123; System.out.println(&quot;内层&quot;); return 0; &#125; return a/b; &#125; 自定义异常JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常： 1234567public class MyException extends Exception &#123; //直接继承即可&#125;public static void main(String[] args) throws MyException &#123; throw new MyException(); //直接使用 &#125; 也可以使用父类的带描述的构造方法： 12345678910public class MyException extends Exception &#123; public MyException(String message)&#123; super(message); &#125;&#125;public static void main(String[] args) throws MyException &#123; throw new MyException(&quot;出现了自定义的错误&quot;);&#125; 捕获异常指定的类型，会捕获其所有子异常类型： 12345try &#123; throw new MyException(&quot;出现了自定义的错误&quot;);&#125; catch (Exception e) &#123; //捕获父异常类型 System.out.println(&quot;捕获到异常&quot;);&#125; 多重异常捕获和finally关键字当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： 123456789try &#123; //....&#125; catch (NullPointerException e) &#123;&#125; catch (IndexOutOfBoundsException e)&#123;&#125; catch (RuntimeException e)&#123;&#125; 注意，类似于if-else if的结构，父异常类型只能放在最后！ 123456789try &#123; //....&#125; catch (RuntimeException e)&#123; //父类型在前，会将子类的也捕获&#125; catch (NullPointerException e) &#123; //永远都不会被捕获&#125; catch (IndexOutOfBoundsException e)&#123; //永远都不会被捕获&#125; 如果希望把这些异常放在一起进行处理： 12345try &#123; //....&#125; catch (NullPointerException | IndexOutOfBoundsException e) &#123; //用|隔开每种类型即可&#125; 当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给finally语句块来处理： 1234567try &#123; //....&#125;catch (Exception e)&#123;&#125;finally &#123; System.out.println(&quot;lbwnb&quot;); //无论是否出现异常，都会在最后执行&#125; try语句块至少要配合catch或finally中的一个： 123456try &#123; int a = 10; a /= 0;&#125;finally &#123; //不捕获异常，程序会终止，但在最后依然会执行下面的内容 System.out.println(&quot;lbwnb&quot;);&#125; 思考：try、catch和finally执行顺序： 123456789private static int test(int a)&#123; try&#123; return a; &#125;catch (Exception e)&#123; return 0; &#125;finally &#123; a = a + 1; &#125;&#125; Java泛型与集合类在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 走进泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ 1234567891011public class Score &#123; String name; String id; Object score; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object score) &#123; this.name = name; this.id = id; this.score = score; &#125;&#125; 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： 123456789101112public static void main(String[] args) &#123; Score score = new Score(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;); //是String类型的 //.... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错&#125;//运行时出现异常！Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer at com.test.Main.main(Main.java:14) 使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法） 为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。 1234567891011public class Score&lt;T&gt; &#123; //将Score转变为泛型类&lt;T&gt; String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) &#123; //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; &#125;&#125; 123456public static void main(String[] args) &#123; //直接确定Score的类型是字符串类型的成绩 Score&lt;String&gt; score = new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;); Integer i = score.score; //编译不通过，因为成员变量score类型被定为String！&#125; 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！ 泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全） 12345//反编译后的代码public static void main(String[] args) &#123; Score score = new Score(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;); String i = (String)score.score; //其实依然会变为强制类型转换，但是这是由编译器帮我们完成的 &#125; 像这样在编译后泛型的内容消失转变为Object的情况称为类型擦除（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。 综上，泛型其实就是一种类型参数，用于指定类型。 泛型的使用泛型类上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是类型的英文单词首字母，当然也可以添加数字和其他的字符。 1234567891011public class Score&lt;T&gt; &#123; //将Score转变为泛型类&lt;T&gt; String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) &#123; //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; &#125;&#125; 在一个普通类型中定义泛型，泛型T称为参数化类型，在定义泛型类的引用时，需要明确指出类型： 1Score&lt;String&gt; score = new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;); 此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型： 1Integer i = score.score; //编译不通过，因为成员变量score明确为String类型 注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用： 1static T score; //错误，不能在静态成员上定义 由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。 泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！ 1Score&lt;double&gt; score = new Score&lt;double&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 90.5); //编译不通过 那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。 类的泛型方法泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可： 1234567public T getScore() &#123; //若方法的返回值类型为泛型，那么编译器会自动进行推断 return score;&#125;public void setScore(T score) &#123; //若方法的形式参数为泛型，那么实参只能是定义时的类型 this.score = score;&#125; 12Score&lt;String&gt; score = new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);score.setScore(10); //编译不通过，因为只接受String类型 同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型） 自定义泛型方法那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义： 123public static &lt;E&gt; void test(E e)&#123; //在方法定义前声明泛型 System.out.println(e);&#125; 同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定： 123public &lt;E&gt; void test(E e)&#123; System.out.println(e);&#125; 其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。 注意一定要区分类定义的泛型和方法前定义的泛型！ 泛型引用可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型： 1Score&lt;Integer&gt; score; //声明泛型为Integer类型 如果不希望指定类型，或是希望此引用类型可以引用任意泛型的Score类对象，可以使用?通配符，来表示自动匹配任意的可用类型： 1Score&lt;?&gt; score; //score可以引用任意的Score类型对象了！ 那么使用通配符之后，得到的泛型成员变量会是什么类型呢？ 1Object o = score.getScore(); //只能变为Object 因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。 在学习了泛型的界限后，我们还会继续了解通配符的使用。 泛型的界限现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义： 123456789101112131415public class Score&lt;T extends Number&gt; &#123; //设定泛型上界，必须是Number的子类 private final String name; private final String id; private T score; public Score(String name, String id, T score) &#123; this.name = name; this.id = id; this.score = score; &#125; public T getScore() &#123; return score; &#125;&#125; 通过extends关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。 同样的，泛型通配符也支持泛型的界限： 1Score&lt;? extends Number&gt; score; //限定为匹配Number及其子类的类型 同理，既然泛型有上限，那么也有下限： 1Score&lt;? super Integer&gt; score; //限定为匹配Integer及其父类 通过super关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。 图解如下： 那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？ 12Score&lt;? extends Number&gt; score = new Score&lt;&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);Number o = score.getScore(); //得到的结果为上界类型 也就是说，一旦我们指定了上界后，编译器就将范围从原始类型Object提升到我们指定的上界Number，但是依然无法明确具体类型。思考：那如果定义下限呢？ 那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢： 123456789101112131415161718192021222324//使用javap -l 进行反编译public class com.test.Score&lt;T extends java.lang.Number&gt; &#123; public com.test.Score(java.lang.String, java.lang.String, T); LineNumberTable: line 8: 0 line 9: 4 line 10: 9 line 11: 14 line 12: 19 LocalVariableTable: Start Length Slot Name Signature 0 20 0 this Lcom/test/Score; 0 20 1 name Ljava/lang/String; 0 20 2 id Ljava/lang/String; 0 20 3 score Ljava/lang/Number; //可以看到score的类型直接被编译为Number类 public T getScore(); LineNumberTable: line 15: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/test/Score;&#125; 因此，一旦确立上限后，编译器会自动将类型提升到上限类型。 钻石运算符我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码： 123Score&lt;Integer&gt; score = new Score&lt;Integer&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10); //1.7之前Score&lt;Integer&gt; score = new Score&lt;&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10); //1.7之后 泛型与多态泛型不仅仅可以可以定义在类上，同时也能定义在接口上： 1234public interface ScoreInterface&lt;T&gt; &#123; T getScore(); void setScore(T t);&#125; 当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。 1234567891011121314151617181920public class Score&lt;T&gt; implements ScoreInterface&lt;T&gt;&#123; //将Score转变为泛型类&lt;T&gt; private final String name; private final String id; private T score; public Score(String name, String id, T score) &#123; this.name = name; this.id = id; this.score = score; &#125; public T getScore() &#123; return score; &#125; @Override public void setScore(T score) &#123; this.score = score; &#125;&#125; 123456789101112public class StringScore implements ScoreInterface&lt;String&gt;&#123; //在实现时明确类型 @Override public String getScore() &#123; return null; &#125; @Override public void setScore(String s) &#123; &#125;&#125; 抽象类同理，这里就不多做演示了。 多态类型擦除思考一个问题，既然继承后明确了泛型类型，那么为什么@Override不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？ 1234567891011121314151617181920212223class A&lt;T&gt;&#123; private T t; public T get()&#123; return t; &#125; public void set(T t)&#123; this.t=t; &#125;&#125;class B extends A&lt;Number&gt;&#123; private Number n; @Override public Number get()&#123; //这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！ return t; &#125; @Override public void set(Number t)&#123; this.t=t; &#125;&#125; 通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写： 123456789@Overridepublic Object get()&#123; return this.get();//调用返回Number的那个方法&#125;@Overridepublic void set(Object t )&#123; this.set((Number)t ); //调用参数是Number的那个方法&#125; 数据结构基础警告！本章最难的部分！ 学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。 在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。 通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！ 线性表线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。 顺序表将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构，而以这种方式实现的线性表，我们称为顺序表。 同样的，表中的每一个个体都被称为元素，元素左边的元素（上一个元素），称为前驱，同理，右边的元素（后一个元素）称为后驱。 我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。 目标：以数组为底层，编写以下抽象类的具体实现 1234567891011121314151617181920212223242526272829303132/** * 线性表抽象类 * @param &lt;E&gt; 存储的元素(Element)类型 */public abstract class AbstractList&lt;E&gt; &#123; /** * 获取表的长度 * @return 顺序表的长度 */ public abstract int size(); /** * 添加一个元素 * @param e 元素 * @param index 要添加的位置(索引) */ public abstract void add(E e, int index); /** * 移除指定位置的元素 * @param index 位置 * @return 移除的元素 */ public abstract E remove(int index); /** * 获取指定位置的元素 * @param index 位置 * @return 元素 */ public abstract E get(int index);&#125; 链表数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构 实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象） 利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！ 比较：顺序表和链表的优异？ 顺序表优缺点： 访问速度快，随机访问性能高 插入和删除的效率低下，极端情况下需要变更整个表 不易扩充，需要复制并重新创建数组 链表优缺点： 插入和删除效率高，只需要改变连接点的指向即可 动态扩充容量，无需担心容量问题 访问元素需要依次寻找，随机访问元素效率低下 链表只能指向后面，能不能指向前面呢？双向链表！ 栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！ 栈栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。 向栈中插入一个元素时，称为入栈（压栈），移除栈顶元素称为出栈，我们需要尝试实现以下抽象类型： 123456789101112131415161718/** * 抽象类型栈，待实现 * @param &lt;E&gt; 元素类型 */public abstract class AbstractStack&lt;E&gt; &#123; /** * 出栈操作 * @return 栈顶元素 */ public abstract E pop(); /** * 入栈操作 * @param e 元素 */ public abstract void push(E e);&#125; 其实，我们的JVM在处理方法调用时，也是一个栈操作： 所以说，如果玩不好递归，就会像这样： 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; go(); &#125; private static void go()&#123; go(); &#125;&#125;Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) ... 栈的深度是有限制的，如果达到限制，将会出现StackOverflowError错误（注意是错误！说明是JVM出现了问题） 队列队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。 所以我们要实现以下内容： 1234567891011121314151617181920/** * * @param &lt;E&gt; */public abstract class AbstractQueue&lt;E&gt; &#123; /** * 进队操作 * @param e 元素 */ public abstract void offer(E e); /** * 出队操作 * @return 元素 */ public abstract E poll();&#125; 二叉树本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。 树我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。 一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为根结点，而结点拥有的子节点数量称为度，每向下一级称为一个层次，树中出现的最大层次称为树的深度(高度)。 二叉树二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右） 数学性质： 在二叉树的第i层上最多有2^(i-1) 个节点。 二叉树中如果深度为k，那么最多有2^k-1个节点。 设计一个二叉树结点类： 12345public class TreeNode&lt;E&gt; &#123; public E e; //当前结点数据 public TreeNode&lt;E&gt; left; //左子树 public TreeNode&lt;E&gt; right; //右子树&#125; 二叉树的遍历顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式： 前序遍历：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF 中序遍历：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF 后序遍历：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA 满二叉树和完全二叉树满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。 https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.examw.com%2Fncre%2FFiles%2F2011-6%2F20%2F93236613.gif&amp;refer=http%3A%2F%2Fwww.examw.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634373420&amp;t=19f3ed8195b15d0b8f49201cc2803759 其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。 快速查找我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？ 哈希表通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！ 不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做hashcode()的方法？而这个方法呢，就是为了更好地支持哈希表的实现。hashcode()默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。 哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样： https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2127470%2F202012%2F2127470-20201222194727385-1606433879.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634376519&amp;t=8cc6fc7a35e695cc5ba12687974daa54 数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。 1234//假设hash表长度为16，hash算法为：private int hash(int hashcode)&#123; return hashcode % 16;&#125; 设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为hash碰撞，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。 当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲） 二叉排序树我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样： 不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为二叉排序树。利用二分搜索的思想，我们就可以快速查找某个节点！ 平衡二叉树在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样： https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20191127151205330.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE5MTA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634378465&amp;t=eb9bf93cfb9191362d1170b93b06d902 显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。 现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为平衡二叉树，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况： 左左失衡 右右失衡 左右失衡 右左失衡 通过以上四种情况的处理，最终得到维护平衡二叉树的算法。 红黑树红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！ https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1301290%2F201904%2F1301290-20190418213139526-1239863354.jpg&amp;refer=http%3A%2F%2Fimg2018.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634381313&amp;t=d60b654d81ee3930b8518f194c976409 红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 我们来看看一个节点，是如何插入到红黑树中的： 基本的 插入规则和平衡二叉树一样，但是在插入后： 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1 如果 X 的 uncle (叔叔) 是红色 3.1.1 将 parent 和 uncle 标记为黑色3.1.2 将 grand parent (祖父) 标记为红色3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子)3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子)其实这种情况下处理就和我们的平衡二叉树一样了 认识集合类集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。 集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。 集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。 https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.mianfeiwendang.com%2Fpic%2F29a5b61e9e5e19fe10103b4c%2F1-356-jpg_6_0_______-858-0-0-858.jpg&amp;refer=http%3A%2F%2Fwww.mianfeiwendang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634434848&amp;t=e696ab71af584ef08a38fc328956586c 数组与集合相同之处： 它们都是容器，都能够容纳一组元素。 不同之处： 数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 集合根接口Collection本接口中定义了全部的集合基本操作，我们可以在源码中看看。 我们再来看看List和Set以及Queue接口。 集合类的使用List列表首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。 先看看ArrayList的源码！ 基本操作12List&lt;String&gt; list = new ArrayList&lt;&gt;(); //默认长度的列表List&lt;String&gt; listInit = new ArrayList&lt;&gt;(100); //初始长度为100的列表 向列表中添加元素： 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;lbwnb&quot;);list.add(&quot;yyds&quot;);list.contains(&quot;yyds&quot;); //是否包含某个元素System.out.println(list); 移除元素： 12345678public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;lbwnb&quot;); list.add(&quot;yyds&quot;); list.remove(0); //按下标移除元素 list.remove(&quot;yyds&quot;); //移除指定元素 System.out.println(list);&#125; 也支持批量操作： 1234567public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.addAll(new ArrayList&lt;&gt;()); //在尾部批量添加元素 list.removeAll(new ArrayList&lt;&gt;()); //批量移除元素（只有给定集合中存在的元素才会被移除） list.retainAll(new ArrayList&lt;&gt;()); //只保留某些元素 System.out.println(list);&#125; 我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。 其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。 1234567891011public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); list.offer(&quot;A&quot;); //入队 System.out.println(list.poll()); //出队 list.push(&quot;A&quot;); list.push(&quot;B&quot;); //进栈 list.push(&quot;C&quot;); System.out.println(list.pop()); System.out.println(list.pop()); //出栈 System.out.println(list.pop());&#125; 利用代码块来快速添加内容前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List 1234List&lt;String&gt; list = new LinkedList&lt;String&gt;()&#123;&#123; //初始化时添加 this.add(&quot;A&quot;); this.add(&quot;B&quot;);&#125;&#125;; 如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。 集合的排序123456789101112List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;()&#123; //Java9才支持匿名内部类使用钻石运算符 &#123; this.add(10); this.add(2); this.add(5); this.add(8); &#125;&#125;;list.sort((a, b) -&gt; &#123; //排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现 return a - b; //返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换&#125;);System.out.println(list); 迭代器集合的遍历所有的集合类，都支持foreach循环！ 12345678910111213public static void main(String[] args) &#123; List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;()&#123; //Java9才支持匿名内部类使用钻石运算符 &#123; this.add(10); this.add(2); this.add(5); this.add(8); &#125; &#125;; for (Integer integer : list) &#123; System.out.println(integer); &#125;&#125; 当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现： 123list.forEach(i -&gt; &#123; System.out.println(i);&#125;); 从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。 12345list.replaceAll((i) -&gt; &#123; if(i == 2) return 3; //将所有的2替换为3 else return i; //不是2就不变&#125;);System.out.println(list); Iterable和Iterator接口我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。 由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。 我们先来看看迭代器里面方法： 123public interface Iterator&lt;E&gt; &#123; //...&#125; 每个集合类都有自己的迭代器，通过iterator()方法来获取： 12345Iterator&lt;Integer&gt; iterator = list.iterator(); //生成一个新的迭代器while (iterator.hasNext())&#123; //判断是否还有下一个元素 Integer i = iterator.next(); //获取下一个元素（获取一个少一个） System.out.println(i);&#125; 迭代器生成后，默认指向第一个元素，每次调用next()方法，都会将指针后移，当指针移动到最后一个元素之后，调用hasNext()将会返回false，迭代器是一次性的，用完即止，如果需要再次使用，需要调用iterator()方法。 1ListIterator&lt;Integer&gt; iterator = list.listIterator(); //List还有一个更好地迭代器实现ListIterator ListIterator是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。 Set集合我们之前已经看过Set接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。 Set集合特点： 不允许出现重复元素 不支持随机访问（不允许通过下标访问） 首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论） 123456789public static void main(String[] args) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(120); //支持插入元素，但是不支持指定位置插入 set.add(13); set.add(11); for (Integer integer : set) &#123; System.out.println(integer); &#125;&#125; 运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用哈希表来实现的，实际的存放顺序是由Hash算法决定的。 那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet： 123456789public static void main(String[] args) &#123; LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); //会自动保存我们的插入顺序 set.add(120); set.add(13); set.add(11); for (Integer integer : set) &#123; System.out.println(integer); &#125;&#125; LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。 还有一种Set叫做TreeSet，它会在元素插入时进行排序： 1234567public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(1); set.add(3); set.add(2); System.out.println(set);&#125; 可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则： 1234567public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;((a, b) -&gt; b - a); //在创建对象时指定规则即可 set.add(1); set.add(3); set.add(2); System.out.println(set);&#125; 现在的结果就是我们自定义的排序规则了。 虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。 Map映射什么是映射我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。 https://bkimg.cdn.bcebos.com/pic/7aec54e736d12f2e89cbcbb64dc2d5628435681d?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg Map接口Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。 我们先来看看Map接口中定义了哪些操作。 HashMap和LinkedHashMapHashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样： 哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。 而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构： 1234567/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table; 这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！ 1234/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。 我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？ 123456/** * The load factor for the hash table. * * @serial */final float loadFactor; 我们还发现HashMap源码中有这样一个变量，也就是负载因子，那么它是干嘛的呢？ 负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是0.75 1234/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f; 那么负载因子是怎么控制扩容的呢？0.75的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。 但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。 当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。 123456/** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; 除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。 123456789/** * HashMap.Node subclass for normal LinkedHashMap entries. */static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。 12345678public static void main(String[] args) &#123; LinkedHashMap&lt;Integer, String&gt; map = new LinkedHashMap&lt;&gt;(16, 0.75f, true); //以访问顺序 map.put(1, &quot;A&quot;); map.put(2, &quot;B&quot;); map.put(3, &quot;C&quot;); map.get(2); System.out.println(map);&#125; 观察结果，我们发现，刚访问的结果被排到了最后一位。 TreeMapTreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样： 12345678910111213141516/** * The comparator used to maintain order in this tree map, or * null if it uses the natural ordering of its keys. * * @serial */private final Comparator&lt;? super K&gt; comparator;private transient Entry&lt;K,V&gt; root;/*** Node in the Tree. Doubles as a means to pass key-value pairs back to* user (see Map.Entry).*/static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; 我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。 Map的使用我们首先来看看Map的一些基本操作： 123456789public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;A&quot;); map.put(2, &quot;B&quot;); map.put(3, &quot;C&quot;); System.out.println(map.get(1)); //获取Key为1的值 System.out.println(map.getOrDefault(0, &quot;K&quot;)); //不存在就返回K map.remove(1); //移除这个Key的键值对&#125; 由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用： 12345678910111213public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;A&quot;); map.put(2, &quot;B&quot;); map.put(3, &quot;C&quot;); map.forEach((k, v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v)); for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123; //也可以获取所有的Entry来foreach int key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&quot; -&gt; &quot;+value); &#125;&#125; 我们也可以单独获取所有的值或者是键： 12345678public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;A&quot;); map.put(2, &quot;B&quot;); map.put(3, &quot;C&quot;); System.out.println(map.keySet()); //直接获取所有的key System.out.println(map.values()); //直接获取所有的值&#125; 再谈Set原理通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！ 12// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); 我们发现，在添加元素时，其实添加的是一个键为我们插入的元素，而值就是PRESENT常量： 123456789101112131415/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 观察其他的方法，也几乎都是在用HashMap做事，所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！ 再来看TreeSet，实际上用的就是我们的TreeMap： 1234/** * The backing map. */private transient NavigableMap&lt;E,Object&gt; m; 同理，这里就不多做阐述了。 JDK1.8新增方法使用最后，我们再来看看JDK1.8中集合类新增的一些操作（之前没有提及的）首先来看看compute方法： 123456789101112public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;A&quot;); map.put(2, &quot;B&quot;); map.compute(1, (k, v) -&gt; &#123; //compute会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+&quot;M&quot;; //这里返回原来的value+M &#125;); map.computeIfPresent(1, (k, v) -&gt; &#123; //当Key存在时存在则计算并赋予新的值 return v+&quot;M&quot;; //这里返回原来的value+M &#125;); System.out.println(map);&#125; 也可以使用computeIfAbsent，当不存在Key时，计算并将键值对放入Map 123456789public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;A&quot;); map.put(2, &quot;B&quot;); map.computeIfAbsent(0, (k) -&gt; &#123; //若不存在则计算并插入新的值 return &quot;M&quot;; //这里返回M &#125;); System.out.println(map);&#125; merge方法用于处理数据： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; List&lt;Student&gt; students = Arrays.asList( new Student(&quot;yoni&quot;, &quot;English&quot;, 80), new Student(&quot;yoni&quot;, &quot;Chiness&quot;, 98), new Student(&quot;yoni&quot;, &quot;Math&quot;, 95), new Student(&quot;taohai.wang&quot;, &quot;English&quot;, 50), new Student(&quot;taohai.wang&quot;, &quot;Chiness&quot;, 72), new Student(&quot;taohai.wang&quot;, &quot;Math&quot;, 41), new Student(&quot;Seely&quot;, &quot;English&quot;, 88), new Student(&quot;Seely&quot;, &quot;Chiness&quot;, 89), new Student(&quot;Seely&quot;, &quot;Math&quot;, 92) ); Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;(); students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -&gt; System.out.println(&quot;key:&quot; + k + &quot;总分&quot; + &quot;value:&quot; + v));&#125;static class Student &#123; private final String name; private final String type; private final int score; public Student(String name, String type, int score) &#123; this.name = name; this.type = type; this.score = score; &#125; public String getName() &#123; return name; &#125; public int getScore() &#123; return score; &#125; public String getType() &#123; return type; &#125;&#125; 集合的嵌套既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？ 1234567public static void main(String[] args) &#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); //每一个映射都是 字符串&lt;-&gt;列表 map.put(&quot;卡布奇诺今犹在&quot;, new LinkedList&lt;&gt;()); map.put(&quot;不见当年倒茶人&quot;, new LinkedList&lt;&gt;()); System.out.println(map.keySet()); System.out.println(map.values());&#125; 通过Key获取到对应的值后，就是一个列表： 12map.get(&quot;卡布奇诺今犹在&quot;).add(10);System.out.println(map.get(&quot;卡布奇诺今犹在&quot;).get(0)); 让套娃继续下去： 123public static void main(String[] args) &#123; Map&lt;Integer, Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; map = new HashMap&lt;&gt;();&#125; 你也可以使用List来套娃别的： 123public static void main(String[] args) &#123; List&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt; list = new LinkedList&lt;&gt;();&#125; 流Stream和Optional的使用Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F723b4e9e03e9f1cbd9078f60b265e3ddc8a582aa.jpg&amp;refer=http%3A%2F%2Fseo-1255598498.file.myqcloud.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634782830&amp;t=8d9a60d60087bec5ce0d09b763eb3805 它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理： 12345678910111213141516171819public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;A&quot;); list.add(&quot;B&quot;); list.add(&quot;C&quot;); //移除为B的元素 Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; if(iterator.next().equals(&quot;B&quot;)) iterator.remove(); &#125; //Stream操作 list = list //链式调用 .stream() //获取流 .filter(e -&gt; !e.equals(&quot;B&quot;)) //只允许所有不是B的元素通过流水线 .collect(Collectors.toList()); //将流水线中的元素重新收集起来，变回List System.out.println(list);&#125; 可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下： 1234567891011121314151617public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //去重（使用equals判断） .sorted((a, b) -&gt; b - a) //进行倒序排列 .map(e -&gt; e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list);&#125; 当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句） 注意：不能认为每一步是直接依次执行的！ 1234567891011121314151617List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);list.add(3);list = list .stream() .distinct() //断点 .sorted((a, b) -&gt; b - a) .map(e -&gt; &#123; System.out.println(&quot;&gt;&gt;&gt; &quot;+e); //断点 return e+1; &#125;) .limit(2) //断点 .collect(Collectors.toList());//实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！ 接下来，我们用一堆随机数来进行更多流操作的演示： 123456789public static void main(String[] args) &#123; Random random = new Random(); //Random是一个随机数工具类 random .ints(-100, 100) //生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -&gt; i &lt; 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印&#125; 我们可以生成一个统计实例来帮助我们快速进行统计： 12345678910public static void main(String[] args) &#123; Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值&#125; 普通的List只需要一个方法就可以直接转换到方便好用的IntStream了： 1234567891011public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -&gt; i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics();&#125; 我们还可以通过flat来对整个流进行进一步细分： 1234567891011public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;A,B&quot;); list.add(&quot;C,D&quot;); list.add(&quot;E,F&quot;); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -&gt; Arrays.stream(e.split(&quot;,&quot;))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果&#125; 我们也可以只通过Stream来完成所有数字的和，使用reduce方法： 1234567891011public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -&gt; a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值 System.out.println(sum);&#125; 通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？ Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。 123456public static void main(String[] args) &#123; String str = null; if(str != null)&#123; //当str不为空时添加元素到List中 list.add(str); &#125;&#125; 有了Optional之后，我们就可以这样写： 12345public static void main(String[] args) &#123; String str = null; Optional&lt;String&gt; optional = Optional.ofNullable(str); //转换为Optional optional.ifPresent(System.out::println); //当存在时再执行方法&#125; 就类似于Kotlin中的： 12var str : String? = nullstr?.upperCase() 我们可以选择直接get或是当值为null时，获取备选值： 123456public static void main(String[] args) &#123; String str = null; Optional optional = Optional.ofNullable(str); //转换为Optional（可空） System.out.println(optional.orElse(&quot;lbwnb&quot;)); // System.out.println(optional.get()); 这样会直接报错&#125; 同样的，Optional也支持过滤操作和映射操作，不过是对于单对象而言： 12345public static void main(String[] args) &#123; String str = &quot;A&quot;; Optional optional = Optional.ofNullable(str); //转换为Optional（可空） System.out.println(optional.filter(s -&gt; s.equals(&quot;B&quot;)).get()); //被过滤了，此时元素为null，获取时报错&#125; 123456public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); String str = &quot;A&quot;; Optional optional = Optional.ofNullable(str); //转换为Optional（可空） System.out.println(optional.map(s -&gt; s + &quot;A&quot;).get()); //在尾部追加一个A&#125; 其他操作自学了解。 Arrays和Collections的使用Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法： 1234567891011/** * This class contains various methods for manipulating arrays (such as * sorting and searching). This class also contains a static factory * that allows arrays to be viewed as lists. &lt;- 注意，这句话很关键 * * @author Josh Bloch * @author Neal Gafter * @author John Rose * @since 1.2 */public class Arrays &#123; 由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如： 123456public static void main(String[] args) &#123; int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;; Arrays.sort(array); //直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序） System.out.println(array); //由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果 System.out.println(Arrays.toString(array)); //我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来&#125; 123456public static void main(String[] args) &#123; int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;; Arrays.sort(array); System.out.println(&quot;排序后的结果：&quot;+Arrays.toString(array)); System.out.println(&quot;目标元素3位置为：&quot;+Arrays.binarySearch(array, 3)); //二分搜素，必须是已经排序好的数组！&#125; 1234567public static void main(String[] args) &#123; int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;; Arrays .stream(array) //将数组转换为流进行操作 .sorted() .forEach(System.out::println);&#125; 12345678910111213public static void main(String[] args) &#123; int[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;; int[] array2 = Arrays.copyOf(array, array.length); //复制一个一模一样的数组 System.out.println(Arrays.toString(array2)); System.out.println(Arrays.equals(array, array2)); //比较两个数组是否值相同 Arrays.fill(array, 0); //将数组的所有值全部填充为指定值 System.out.println(Arrays.toString(array)); Arrays.setAll(array2, i -&gt; array2[i] + 2); //依次计算每一个元素（注意i是下标位置） System.out.println(Arrays.toString(array2)); //这里计算让每个元素值+2&#125; 思考：当二维数组使用Arrays.equals()进行比较以及Arrays.toString()进行打印时，还会得到我们想要的结果吗？ 123456789public static void main(String[] args) &#123; Integer[][] array = &#123;&#123;1, 5&#125;, &#123;2, 4&#125;, &#123;7, 3&#125;, &#123;6&#125;&#125;; Integer[][] array2 = &#123;&#123;1, 5&#125;, &#123;2, 4&#125;, &#123;7, 3&#125;, &#123;6&#125;&#125;; System.out.println(Arrays.toString(array)); //这样还会得到我们想要的结果吗？ System.out.println(Arrays.equals(array2, array)); //这样还会得到true吗？ System.out.println(Arrays.deepToString(array)); //使用deepToString就能到打印多维数组 System.out.println(Arrays.deepEquals(array2, array)); //使用deepEquals就能比较多维数组&#125; 那么，一开始提到的当做List进行操作呢？我们可以使用Arrays.asList()来将数组转换为一个 固定长度的List 123456789101112public static void main(String[] args) &#123; Integer[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;; List&lt;Integer&gt; list = Arrays.asList(array); //不支持基本类型数组，必须是对象类型数组 Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); //也可以逐个添加，因为是可变参数 list.add(1); //此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作 list.remove(0); //同理，也不支持移除 list.set(0, 8); //直接设置指定下标的值就可以 list.sort(Comparator.reverseOrder()); //也可以执行排序操作 System.out.println(list); //也可以像List那样直接打印&#125; 文字游戏：allows arrays to be viewed as lists，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样： 1234public static void main(String[] args) &#123; Integer[] array = &#123;1, 5, 2, 4, 7, 3, 6&#125;; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array));&#125; 通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。 既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类： 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.max(list); Collections.min(list);&#125; 当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。 集合类编程实战反转链表1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9 转换为 1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9 现在有一个单链表，尝试将其所有节点倒序排列 1234567891011121314151617181920212223242526272829public class Main &#123; public static void main(String[] args) &#123; Node head = new Node(1); head.next = new Node(3); head.next.next = new Node(5); head.next.next.next = new Node(7); head.next.next.next.next = new Node(9); head = reverse(head); while (head != null)&#123; System.out.println(head.value+&quot; &quot;); head = head.next; &#125; &#125; public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125; &#125; public static Node reverse(Node head) &#123; //在这里实现 &#125;&#125; 重建二叉树现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。 https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTEwMTExNTE3NDcx?x-oss-process=image/format,png 实现计算器实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3/1.321，得到结果为：2.2 字符串匹配（KMP算法）现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。 Java I/O注意：这块会涉及到操作系统和计算机组成原理相关内容。 I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。 我们可以大致看一下整个计算机的总线结构： https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1896043%2F202005%2F1896043-20200507143508957-1866569205.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637387700&amp;t=e6a5ade66f8e4af2ac64d12e6dd77dec 常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。 而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。 JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO， 字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。 文件流要学习和使用IO，首先就要从最易于理解的读取文件开始说起。 文件字节流首先介绍一下FileInputStream，通过它来获取文件的输入流。 12345678public static void main(String[] args) &#123; try &#123; FileInputStream inputStream = new FileInputStream(&quot;路径&quot;); //路径支持相对路径和绝对路径 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！ 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！ 1234567891011121314public static void main(String[] args) &#123; FileInputStream inputStream = null; //定义可以先放在try外部 try &#123; inputStream = new FileInputStream(&quot;路径&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; //建议在finally中进行，因为这个是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法） 12345678910public static void main(String[] args) &#123; //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(&quot;路径&quot;)) &#123; //直接在try()中定义要在完成之后释放的资源 &#125; catch (IOException e) &#123; //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); &#125; //无需再编写finally语句块，因为在最后自动帮我们调用了close()&#125; 之后为了方便，我们都使用此语法进行教学。 12345678910public static void main(String[] args) &#123; //test.txt：a try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123; //使用read()方法进行字符读取 System.out.println((char) inputStream.read()); //读取一个字节的数据（英文字母只占1字节，中文占2字节） System.out.println(inputStream.read()); //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成： 1234567891011public static void main(String[] args) &#123; //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123; int tmp; while ((tmp = inputStream.read()) != -1)&#123; //通过while循环来一次性读完内容 System.out.println((char)tmp); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量） 12345try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123; System.out.println(inputStream.available()); //查看剩余数量&#125;catch (IOException e)&#123; e.printStackTrace();&#125; 当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。 12345678910public static void main(String[] args) &#123; //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123; byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 也可以控制要读取数量： 1System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1 通过skip()方法可以跳过指定数量的字节： 123456789public static void main(String[] args) &#123; //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123; System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。 既然有输入流，那么文件输出流也是必不可少的： 12345678public static void main(String[] args) &#123; //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;)) &#123; //注意：若此文件不存在，会直接创建这个文件！ &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容： 12345678910public static void main(String[] args) &#123; try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;)) &#123; outputStream.write(&#x27;c&#x27;); //同read一样，可以直接写入内容 outputStream.write(&quot;lbwnb&quot;.getBytes()); //也可以直接写入byte[] outputStream.write(&quot;lbwnb&quot;.getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现： 12345678public static void main(String[] args) &#123; try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;, true)) &#123; outputStream.write(&quot;lb&quot;.getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 利用输入流和输出流，就可以轻松实现文件的拷贝了： 123456789101112public static void main(String[] args) &#123; try(FileOutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;); FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123; //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1)&#123; //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 文件字符流字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用： 12345678public static void main(String[] args) &#123; try(FileReader reader = new FileReader(&quot;test.txt&quot;))&#123; reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 同理，字符流只支持char[]类型作为存储： 123456789public static void main(String[] args) &#123; try(FileReader reader = new FileReader(&quot;test.txt&quot;))&#123; char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 既然有了Reader肯定也有Writer： 12345678910public static void main(String[] args) &#123; try(FileWriter writer = new FileWriter(&quot;output.txt&quot;))&#123; writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write(&#x27;牛&#x27;); writer.append(&#x27;牛&#x27;); //其实功能和write一样 writer.flush(); //刷新 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码： 1234567891011121314151617181920212223/** * Appends the specified character to this writer. * * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt; * behaves in exactly the same way as the invocation * * &lt;pre&gt; * out.write(c) &lt;/pre&gt; * * @param c * The 16-bit character to append * * @return This writer * * @throws IOException * If an I/O error occurs * * @since 1.5 */public Writer append(char c) throws IOException &#123; write(c); return this;&#125; append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。 练习：尝试一下用Reader和Writer来拷贝纯文本文件 File类File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。 123456789public static void main(String[] args) &#123; File file = new File(&quot;test.txt&quot;); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行&#125; 通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容： 12345File file = new File(&quot;/&quot;);System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表for (File f : file.listFiles())&#123; //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径&#125; 如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流： 123456File file = new File(&quot;test.txt&quot;);try (FileInputStream inputStream = new FileInputStream(file))&#123; //直接做参数 System.out.println(inputStream.available());&#125;catch (IOException e)&#123; e.printStackTrace();&#125; 练习：尝试拷贝文件夹下的所有文件到另一个文件夹 缓冲流虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。 https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.wityx.com%2Fimage%2F201908%2F480873DBD936EBA9518F721ACDC22BFE.png&amp;refer=http%3A%2F%2Fwww.wityx.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637457276&amp;t=b4f7d52f08d9d5815baca0b21a01f925 缓冲字节流要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可： 1234567public static void main(String[] args) &#123; try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123; //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式 12345678910111213public void close() throws IOException &#123; byte[] buffer; while ( (buffer = buf) != null) &#123; if (bufUpdater.compareAndSet(this, buffer, null)) &#123; //CAS无锁算法，并发会用到，暂时不管 InputStream input = in; in = null; if (input != null) input.close(); return; &#125; // Else retry in case a new buf was CASed in fill() &#125;&#125; 实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。 我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组： 123456/** * The internal buffer array where the data is stored. When necessary, * it may be replaced by another array of * a different size. */protected volatile byte buf[]; I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍： 12345678910111213141516171819/** * Marks the current position in this input stream. A subsequent * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at * the last marked position so that subsequent reads re-read the same bytes. * &lt;p&gt; * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to * allow that many bytes to be read before the mark position gets * invalidated. * &lt;p&gt; * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;. * * @param readlimit the maximum limit of bytes that can be read before * the mark position becomes invalid. * @see java.io.FilterInputStream#in * @see java.io.FilterInputStream#reset() */public synchronized void mark(int readlimit) &#123; in.mark(readlimit);&#125; 当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。 123456789101112public static void main(String[] args) &#123; try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123; bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果： 123456789101112public static void main(String[] args) &#123; try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;), 1))&#123; //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作： 12345678public static void main(String[] args) &#123; try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123; outputStream.write(&quot;lbwnb&quot;.getBytes()); outputStream.flush(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 操作和FileOutputStream一致，这里就不多做介绍了。 缓冲字符流缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象： 1234567public static void main(String[] args) &#123; try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123; System.out.println((char) reader.read()); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用和reader也是一样的，内部也包含一个缓存数组： 1private char cb[]; 相比Reader更方便的是，它支持按行读取： 1234567public static void main(String[] args) &#123; try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123; System.out.println(reader.readLine()); //按行读取 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流： 123456789101112public static void main(String[] args) &#123; try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123; reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 它同样也支持mark()和reset()操作： 12345678910public static void main(String[] args) &#123; try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123; reader.mark(1); System.out.println((char) reader.read()); reader.reset(); System.out.println((char) reader.read()); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便： 123456789public static void main(String[] args) &#123; try (BufferedWriter reader = new BufferedWriter(new FileWriter(&quot;output.txt&quot;)))&#123; reader.newLine(); //使用newLine进行换行 reader.write(&quot;汉堡做滴彳亍不彳亍&quot;); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 转换流有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？ 1234567public static void main(String[] args) &#123; try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(&quot;test.txt&quot;)))&#123; //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(&quot;lbwnb&quot;); //以操作Writer的样子写入OutputStream &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现： 1234567public static void main(String[] args) &#123; try(InputStreamReader reader = new InputStreamReader(new FileInputStream(&quot;test.txt&quot;)))&#123; //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。 打印流打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。 1public final static PrintStream out = null; 可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印： 1234567public static void main(String[] args) &#123; try(PrintStream stream = new PrintStream(new FileOutputStream(&quot;test.txt&quot;)))&#123; stream.println(&quot;lbwnb&quot;); //其实System.out就是一个PrintStream &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。 https://img-blog.csdn.net/20180906143936647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGkxMzg5Nzc0MTU1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70 因此实际上内部还包含这两个内容： 123456/** * Track both the text- and character-output streams, so that their buffers * can be flushed without flushing the entire stream. */private BufferedWriter textOut;private OutputStreamWriter charOut; 与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。 数据流数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取： 1234567public static void main(String[] args) &#123; try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123; System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 用于写入基本数据类型： 1234567public static void main(String[] args) &#123; try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123; dataOutputStream.writeBoolean(false); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。 对象流既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。 1234567891011121314151617181920public static void main(String[] args) &#123; try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;)); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123; People people = new People(&quot;lbw&quot;); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); &#125;catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;static class People implements Serializable&#123; //必须实现Serializable接口才能被序列化 String name; public People(String name)&#123; this.name = name; &#125;&#125; 在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本： 123456789static class People implements Serializable&#123; private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name)&#123; this.name = name; &#125;&#125; 当发生版本不匹配时，会无法反序列化为对象： 123456789java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461) at com.test.Main.main(Main.java:27) 如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字： 12345678910111213141516171819202122public static void main(String[] args) &#123; try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;)); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123; People people = new People(&quot;lbw&quot;); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null &#125;catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;static class People implements Serializable&#123; private static final long serialVersionUID = 1234567; transient String name; public People(String name)&#123; this.name = name; &#125;&#125; 其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。 Java I/O编程实战图书管理系统要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。 Java多线程注意：本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。 https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhiphotos.baidu.com%2Fdoc%2Fpic%2Fitem%2Faec379310a55b3193e6caaf24aa98226cefc179b.jpg&amp;refer=http%3A%2F%2Fhiphotos.baidu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637499744&amp;t=1df3c2095bc9a8cbe8cd9d0974644b7c 在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？ https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.51cto.com%2Fwyfs02%2FM00%2F84%2F3A%2FwKiom1eIqY7il2J7AAAyvcssSjs721.gif&amp;refer=http%3A%2F%2Fs2.51cto.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637474421&amp;t=aef9a39ea3a09d6d67e8d4b769036446 后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。 在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程： 12345678public static void main(String[] args) &#123; ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) &#123; System.out.println(info.getThreadName()); &#125;&#125; 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。 线程的创建和启动通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式： 123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object&#x27;s * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 创建好后，通过调用start()方法来运行此线程： 123456public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; //直接编写逻辑 System.out.println(&quot;我是另一个线程！&quot;); &#125;); t.start(); //调用此方法来开始执行此线程&#125; 可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果： 12345678910111213public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;我是线程：&quot;+Thread.currentThread().getName()); System.out.println(&quot;我正在计算 0-10000 之间所有数的和...&quot;); int sum = 0; for (int i = 0; i &lt;= 10000; i++) &#123; sum += i; &#125; System.out.println(&quot;结果：&quot;+sum); &#125;); t.start(); System.out.println(&quot;我是主线程！&quot;);&#125; 我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果： 1234567891011121314public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;我是一号线程：&quot;+i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;我是二号线程：&quot;+i); &#125; &#125;); t1.start(); t2.start();&#125; 我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！ 注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！ https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liuhaihua.cn%2Fwp-content%2Fuploads%2F2019%2F09%2F3AfuQrV.png&amp;refer=http%3A%2F%2Fwww.liuhaihua.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637477978&amp;t=d986b270854b3d7c54f816f9103084bc 实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间： 123456789public static void main(String[] args) throws InterruptedException &#123; System.out.println(&quot;l&quot;); Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s System.out.println(&quot;b&quot;); Thread.sleep(1000); System.out.println(&quot;w&quot;); Thread.sleep(1000); System.out.println(&quot;nb!&quot;);&#125; 我们也可以使用stop()方法来强行终止此线程： 12345678910public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(() -&gt; &#123; Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;打印:&quot;+i); if(i == 20) me.stop(); //此方法会直接终止此线程 &#125; &#125;); t.start();&#125; 虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。 思考：猜猜以下程序输出结果： 12345678910111213141516private static int value = 0;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) value++; System.out.println(&quot;线程1完成&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) value++; System.out.println(&quot;线程2完成&quot;); &#125;); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);&#125; 我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。 线程的休眠和中断我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况： 当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。 当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。 当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。 而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态： 123456789101112public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;l&quot;); Thread.sleep(1000); //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个） System.out.println(&quot;b&quot;); //调用sleep后，线程会直接进入到等待状态，直到时间结束 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t.start();&#125; 通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？ 12345678910111213141516public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; try &#123; Thread.sleep(10000); //休眠10秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t.start(); try &#123; Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法： 123456789101112131415161718public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;线程开始运行！&quot;); while (true)&#123; //无限循环 if(Thread.currentThread().isInterrupted())&#123; //判断是否存在中断标志 break; //响应中断 &#125; &#125; System.out.println(&quot;线程被中断了！&quot;); &#125;); t.start(); try &#123; Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情： 123456789101112131415161718public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;线程开始运行！&quot;); while (true)&#123; if(Thread.currentThread().isInterrupted())&#123; //判断是否存在中断标志 System.out.println(&quot;发现中断信号，复位，继续运行...&quot;); Thread.interrupted(); //复位中断标记（返回值是当前是否有中断标记，这里不用管） &#125; &#125; &#125;); t.start(); try &#123; Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？ 1234567891011121314public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;线程开始运行！&quot;); Thread.currentThread().suspend(); //暂停此线程 System.out.println(&quot;线程继续运行！&quot;); &#125;); t.start(); try &#123; Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.resume(); //恢复此线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。 线程的优先级实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种： MIN_PRIORITY 最低优先级 MAX_PRIORITY 最高优先级 NOM_PRIORITY 常规优先级 1234567public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;线程开始运行！&quot;); &#125;); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级&#125; 优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！ 线程的礼让和加入我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程： 123456789101112131415161718192021public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; System.out.println(&quot;线程1开始运行！&quot;); for (int i = 0; i &lt; 50; i++) &#123; if(i % 5 == 0) &#123; System.out.println(&quot;让位！&quot;); Thread.yield(); &#125; System.out.println(&quot;1打印：&quot;+i); &#125; System.out.println(&quot;线程1结束！&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; System.out.println(&quot;线程2开始运行！&quot;); for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;2打印：&quot;+i); &#125; &#125;); t1.start(); t2.start();&#125; 观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。 当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入： 12345678910111213141516171819202122232425public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; System.out.println(&quot;线程1开始运行！&quot;); for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;1打印：&quot;+i); &#125; System.out.println(&quot;线程1结束！&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; System.out.println(&quot;线程2开始运行！&quot;); for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;2打印：&quot;+i); if(i == 10)&#123; try &#123; System.out.println(&quot;线程1加入到此线程！&quot;); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); t2.start();&#125; 我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看： 12345678910111213141516171819202122232425public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;开始运行！&quot;); for (int i = 0; i &lt; 50; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;打印：&quot;+i); &#125; System.out.println(&quot;线程1结束！&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; System.out.println(&quot;线程2开始运行！&quot;); for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;2打印：&quot;+i); if(i == 10)&#123; try &#123; System.out.println(&quot;线程1加入到此线程！&quot;); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); t2.start();&#125; 实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。 线程锁和线程同步在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理： https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fvlambda.com%2Fimg%3Furl%3Dhttps%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2F2LlmEpiamhyq7hTfsoWa1GMIQlOtRuD8SScvIeB3KD7w4OoGu8wx13lBjMJLhYgYqTHND48X05m901TIEicGg49w%2F640%3Fwx_fmt%3Dpng&amp;refer=http%3A%2F%2Fvlambda.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637562962&amp;t=830ccc4dbe09f2699660bfcc9a292c63 线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多处理器高速缓存机制： https://note.youdao.com/yws/api/personal/file/WEBb1fa2c9cd0784fb19f0d8ebeb8e00976?method=download&amp;shareKey=8d48a5816e60b026adfa21e6735b5e31 高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。 实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！ 悬念破案我们再来回顾一下之前留给大家的悬念： 12345678910111213141516private static int value = 0;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) value++; System.out.println(&quot;线程1完成&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) value++; System.out.println(&quot;线程2完成&quot;); &#125;); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);&#125; 实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！ https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F3154ff892af3cb3373a3b6b82b501a1d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&amp;refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637565388&amp;t=20091d33bae457edc36af7718ef1325b 那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行） 线程锁通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块： 123456789101112131415161718192021222324private static int value = 0;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) &#123; synchronized (Main.class)&#123; value++; &#125; &#125; System.out.println(&quot;线程1完成&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) &#123; synchronized (Main.class)&#123; value++; &#125; &#125; System.out.println(&quot;线程2完成&quot;); &#125;); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);&#125; 我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！ 当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法） 那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？ 1234567891011121314151617181920212223242526private static int value = 0;public static void main(String[] args) throws InterruptedException &#123; Main main1 = new Main(); Main main2 = new Main(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) &#123; synchronized (main1)&#123; value++; &#125; &#125; System.out.println(&quot;线程1完成&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) &#123; synchronized (main2)&#123; value++; &#125; &#125; System.out.println(&quot;线程2完成&quot;); &#125;); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);&#125; 当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。 synchronized关键字也可以作用于方法上，调用此方法时也会获取锁： 1234567891011121314151617181920private static int value = 0;private static synchronized void add()&#123; value++;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) add(); System.out.println(&quot;线程1完成&quot;); &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10000; i++) add(); System.out.println(&quot;线程2完成&quot;); &#125;); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value);&#125; 我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！ 死锁其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住： https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-9852c978350cc5e8641ba778619351bb_b.png&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637568214&amp;t=7740dd98b8e1c4a3bfbd94a30e7f9ff8 我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果： 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws InterruptedException &#123; Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -&gt; &#123; synchronized (o1)&#123; try &#123; Thread.sleep(1000); synchronized (o2)&#123; System.out.println(&quot;线程1&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; synchronized (o2)&#123; try &#123; Thread.sleep(1000); synchronized (o1)&#123; System.out.println(&quot;线程2&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); t2.start();&#125; 那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程： 1234567891011121314151617181920212223nagocoler@NagodeMacBook-Pro ~ % jps51592 Launcher51690 Jps1495551693 Mainnagocoler@NagodeMacBook-Pro ~ % jstack 51693...Java stack information for the threads listed above:===================================================&quot;Thread-1&quot;: at com.test.Main.lambda$main$1(Main.java:46) - waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object) - locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object) at com.test.Main$$Lambda$2/1867750575.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)&quot;Thread-0&quot;: at com.test.Main.lambda$main$0(Main.java:34) - waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object) - locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object) at com.test.Main$$Lambda$1/396873410.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。 不推荐使用 suspend()去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。 wait和notify方法其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么： 123456789101112131415161718192021222324252627public static void main(String[] args) throws InterruptedException &#123; Object o1 = new Object(); Thread t1 = new Thread(() -&gt; &#123; synchronized (o1)&#123; try &#123; System.out.println(&quot;开始等待&quot;); o1.wait(); //进入等待状态并释放锁 System.out.println(&quot;等待结束！&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; synchronized (o1)&#123; System.out.println(&quot;开始唤醒！&quot;); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i &lt; 50; i++) &#123; System.out.println(i); &#125; //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 &#125; &#125;); t1.start(); Thread.sleep(1000); t2.start();&#125; 我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！ notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。 ThreadLocal的使用既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？ 我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。 1234567891011121314public static void main(String[] args) throws InterruptedException &#123; ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -&gt; &#123; local.set(&quot;lbwnb&quot;); //将变量的值给予ThreadLocal System.out.println(&quot;变量值已设定！&quot;); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 &#125;); Thread t2 = new Thread(() -&gt; &#123; System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 &#125;); t1.start(); Thread.sleep(3000); //间隔三秒 t2.start();&#125; 上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容： 123456789101112131415161718192021public static void main(String[] args) throws InterruptedException &#123; ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -&gt; &#123; local.set(&quot;lbwnb&quot;); //将变量的值给予ThreadLocal System.out.println(&quot;线程1变量值已设定！&quot;); try &#123; Thread.sleep(2000); //间隔2秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程1读取变量值：&quot;); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 &#125;); Thread t2 = new Thread(() -&gt; &#123; local.set(&quot;yyds&quot;); //将变量的值给予ThreadLocal System.out.println(&quot;线程2变量值已设定！&quot;); &#125;); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start();&#125; 我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。 我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量： 12345678910public static void main(String[] args) &#123; ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); Thread t = new Thread(() -&gt; &#123; local.set(&quot;lbwnb&quot;); new Thread(() -&gt; &#123; System.out.println(local.get()); &#125;).start(); &#125;); t.start();&#125; 我们可以使用InheritableThreadLocal来解决： 12345678910public static void main(String[] args) &#123; ThreadLocal&lt;String&gt; local = new InheritableThreadLocal&lt;&gt;(); Thread t = new Thread(() -&gt; &#123; local.set(&quot;lbwnb&quot;); new Thread(() -&gt; &#123; System.out.println(local.get()); &#125;).start(); &#125;); t.start();&#125; 在InheritableThreadLocal存放的内容，会自动向子线程传递。 定时器我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现： 123456789101112131415161718192021222324public static void main(String[] args) &#123; new TimerTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start(); //创建并启动此定时任务&#125;static class TimerTask&#123; Runnable task; long time; public TimerTask(Runnable runnable, long time)&#123; this.task = runnable; this.time = time; &#125; public void start()&#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(time); task.run(); //休眠后再运行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？ 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; new TimerLoopTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start(); //创建并启动此定时任务&#125;static class TimerLoopTask&#123; Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime)&#123; this.task = runnable; this.loopTime = loopTime; &#125; public void start()&#123; new Thread(() -&gt; &#123; try &#123; while (true)&#123; //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。 但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务： 123456789public static void main(String[] args) &#123; Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() &#123; //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); //打印当前线程名称 &#125; &#125;, 1000); //执行一个延时任务&#125; 我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程： 12345678910111213141516public class Timer &#123; /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they&#x27;re obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ...&#125; TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动： 1234public Timer(String name) &#123; thread.setName(name); thread.start();&#125; 而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态： 123456789101112131415161718192021222324252627public void run() &#123; try &#123; mainLoop(); &#125; finally &#123; // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) &#123; newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references &#125; &#125;&#125;/** * The main timer loop. (See class comment.) */private void mainLoop() &#123; try &#123; TimerTask task; boolean taskFired; synchronized(queue) &#123; // Wait for queue to become non-empty while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ...&#125; newTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程： 1234567public void cancel() &#123; synchronized(queue) &#123; thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); //唤醒wait使得工作线程结束 &#125;&#125; 因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序： 12345678910public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 &#125; &#125;, 1000);&#125; 守护线程不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂： 1234567891011121314151617public static void main(String[] args) throws InterruptedException&#123; Thread t = new Thread(() -&gt; &#123; while (true)&#123; try &#123; System.out.println(&quot;程序正常运行中...&quot;); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(1000); &#125;&#125; 在守护线程中产生的新线程也是守护的： 1234567891011121314151617181920public static void main(String[] args) throws InterruptedException&#123; Thread t = new Thread(() -&gt; &#123; Thread it = new Thread(() -&gt; &#123; while (true)&#123; try &#123; System.out.println(&quot;程序正常运行中...&quot;); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); it.start(); &#125;); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(1000); &#125;&#125; 再谈集合类并行方法其实我们之前在讲解集合类的根接口时，就发现有这样一个方法： 123default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125; 并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+i));&#125; 我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序： 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEachOrdered(System.out::println);&#125; 我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法： 12345public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, 4, 5, 2, 9, 3, 6, 0&#125;; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr));&#125; 更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！ 12345678public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, 4, 5, 2, 9, 3, 6, 0&#125;; Arrays.parallelSetAll(arr, i -&gt; &#123; System.out.println(Thread.currentThread().getName()); return arr[i]; &#125;); System.out.println(Arrays.toString(arr));&#125; 通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！ Java多线程编程实战这是整个教程最后一个编程实战内容了，下一章节为反射一般开发者使用比较少，属于选学内容，不编排编程实战课程。 生产者与消费者所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。 通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。 Java反射和注解注意：本章节涉及到JVM相关底层原理，难度会有一些大。 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！ Java类加载机制在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的： https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.itboth.com%2F60%2F50%2FUrUVN3.png&amp;refer=http%3A%2F%2Fimg3.itboth.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637635409&amp;t=f25ea82c853619c26897ff5b4d041d5b 在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！ 思考：既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？ 1234567package java.lang;public class String &#123; //JDK提供的String类也是 public static void main(String[] args) &#123; System.out.println(&quot;我姓🐴，我叫🐴nb&quot;); &#125;&#125; 我们发现，会出现以下报错： 12错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行： 实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了！ 12345678public class Main &#123; public static void main(String[] args) &#123; System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 &#125;&#125; 由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。 Class对象通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式： 12345public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;String&gt; clazz = String.class; //使用class关键字，通过类名获取 Class&lt;?&gt; clazz2 = Class.forName(&quot;java.lang.String&quot;); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt; Class&lt;?&gt; clazz3 = new String(&quot;cpdd&quot;).getClass(); //通过实例对象获取&#125; 注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象： 123456Class&lt;String&gt; clazz = String.class; //使用class关键字，通过类名获取Class&lt;?&gt; clazz2 = Class.forName(&quot;java.lang.String&quot;); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;Class&lt;?&gt; clazz3 = new String(&quot;cpdd&quot;).getClass();System.out.println(clazz == clazz2);System.out.println(clazz == clazz3); 通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题： 1234public static void main(String[] args) &#123; Class&lt;?&gt; clazz = int.class; //基本数据类型有Class对象吗？ System.out.println(clazz);&#125; 迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的： 1234567891011121314/** * The &#123;@code Class&#125; instance representing the primitive type * &#123;@code int&#125;. * * @since JDK1.1 */@SuppressWarnings(&quot;unchecked&quot;)public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);/* * Return the Virtual Machine&#x27;s Class object for the named * primitive type */static native Class&lt;?&gt; getPrimitiveClass(String name); //C++实现，并非Java定义 每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。 1234public static void main(String[] args) &#123; Class&lt;?&gt; clazz = int.class; System.out.println(Integer.TYPE == int.class);&#125; 通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？ 123public static void main(String[] args) &#123; System.out.println(Integer.TYPE == Integer.class);&#125; 我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象： 12345678public static void main(String[] args) &#123; Class&lt;String[]&gt; clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(&quot;10&quot;))); //强制类型转换&#125; 再谈instanceof正常情况下，我们使用instanceof进行类型比较： 1234public static void main(String[] args) &#123; String str = &quot;&quot;; System.out.println(str instanceof String);&#125; 它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型： 1234public static void main(String[] args) &#123; String str = &quot;&quot;; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型&#125; 如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用asSubClass()方法： 1234public static void main(String[] args) &#123; Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常&#125; 获取父类信息通过getSuperclass()方法，我们可以获取到父类的Class对象： 1234public static void main(String[] args) &#123; Integer i = 10; System.out.println(i.getClass().getSuperclass());&#125; 也可以通过getGenericSuperclass()获取父类的原始类型的Type： 123456public static void main(String[] args) &#123; Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class);&#125; 我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。 同理，我们也可以像上面这样获取父接口： 12345678910public static void main(String[] args) &#123; Integer i = 10; for (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123; System.out.println(anInterface.getName()); &#125; for (Type genericInterface : i.getClass().getGenericInterfaces()) &#123; System.out.println(genericInterface.getTypeName()); &#125;&#125; 创建类对象既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象： 1234567891011public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Class&lt;Student&gt; clazz = Student.class; Student student = clazz.newInstance(); student.test();&#125;static class Student&#123; public void test()&#123; System.out.println(&quot;萨日朗&quot;); &#125;&#125; 通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？ 12345678910111213141516public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Class&lt;Student&gt; clazz = Student.class; Student student = clazz.newInstance(); student.test();&#125;static class Student&#123; public Student(String text)&#123; &#125; public void test()&#123; System.out.println(&quot;萨日朗&quot;); &#125;&#125; 当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。 1234567891011121314public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Class&lt;Student&gt; clazz = Student.class; Student student = clazz.newInstance(); student.test();&#125;static class Student&#123; private Student()&#123;&#125; public void test()&#123; System.out.println(&quot;萨日朗&quot;); &#125;&#125; 当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象： 1234567891011121314public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class&lt;Student&gt; clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(&quot;what&#x27;s up&quot;); student.test();&#125;static class Student&#123; public Student(String str)&#123;&#125; public void test()&#123; System.out.println(&quot;萨日朗&quot;); &#125;&#125; 通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？ 1234567891011121314public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class&lt;Student&gt; clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(&quot;what&#x27;s up&quot;); student.test();&#125;static class Student&#123; private Student(String str)&#123;&#125; public void test()&#123; System.out.println(&quot;萨日朗&quot;); &#125;&#125; 我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？ 12345Class&lt;Student&gt; clazz = Student.class;Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);constructor.setAccessible(true); //修改访问权限Student student = constructor.newInstance(&quot;what&#x27;s up&quot;);student.test(); 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容） 调用类的方法我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类： 1234567package com.test;public class Student &#123; public void test(String str)&#123; System.out.println(&quot;萨日朗&quot;+str); &#125;&#125; 这次我们通过forName(String)来找到这个类并创建一个新的对象： 1234567public static void main(String[] args) throws ReflectiveOperationException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.test.Student&quot;); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(&quot;test&quot;, String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, &quot;what&#x27;s up&quot;); //通过Method对象的invoke方法来调用方法&#125; 通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。 我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。 同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private： 12345678public static void main(String[] args) throws ReflectiveOperationException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.test.Student&quot;); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(&quot;test&quot;, String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, &quot;what&#x27;s up&quot;); //通过Method对象的invoke方法来调用方法&#125; Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息： 1234567public static void main(String[] args) throws ReflectiveOperationException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.test.Student&quot;); Method method = clazz.getDeclaredMethod(&quot;test&quot;, String.class); //通过方法名和形参类型获取类中的方法 System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型&#125; 当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示： 1Method method = clazz.getDeclaredMethod(&quot;test&quot;, String[].class); 反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。 修改类的属性我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段： 12345678910public static void main(String[] args) throws ReflectiveOperationException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.test.Student&quot;); Object instance = clazz.newInstance(); Field field = clazz.getField(&quot;i&quot;); //获取类的成员字段i field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(&quot;test&quot;); method.invoke(instance);&#125; 在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问： 1234567891011public static void main(String[] args) throws ReflectiveOperationException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.test.Student&quot;); Object instance = clazz.newInstance(); Field field = clazz.getDeclaredField(&quot;i&quot;); //获取类的成员字段i field.setAccessible(true); field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(&quot;test&quot;); method.invoke(instance);&#125; 现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果： 1private final int i = 10; 这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值： 1234567891011121314public static void main(String[] args) throws ReflectiveOperationException &#123; Integer i = 10; Field field = Integer.class.getDeclaredField(&quot;value&quot;); Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i);&#125; 我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型： 1234567891011public static void main(String[] args) throws ReflectiveOperationException &#123; List&lt;String&gt; i = new ArrayList&lt;&gt;(); Field field = ArrayList.class.getDeclaredField(&quot;size&quot;); field.setAccessible(true); field.set(i, 10); i.add(&quot;测试&quot;); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦&#125; 实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！ 再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！ 自定义ClassLoader加载类我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类： 123456789package com.test;public class Test &#123; public String text; public void test(String str)&#123; System.out.println(text+&quot; &gt; 我是测试方法！&quot;+str); &#125;&#125; 通过javac命令，手动编译一个.class文件： 1nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java 编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持： 123456789101112131415//定义一个自己的ClassLoaderstatic class MyClassLoader extends ClassLoader&#123; public Class&lt;?&gt; defineClass(String name, byte[] b)&#123; return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 &#125;&#125;public static void main(String[] args) throws IOException &#123; MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(&quot;Test.class&quot;); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class&lt;?&gt; clazz = classLoader.defineClass(&quot;com.test.Test&quot;, bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件&#125; 现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法： 1234567try &#123; Object obj = clazz.newInstance(); Method method = clazz.getMethod(&quot;test&quot;, String.class); //获取我们定义的test(String str)方法 method.invoke(obj, &quot;哥们这瓜多少钱一斤？&quot;);&#125;catch (Exception e)&#123; e.printStackTrace();&#125; 我们来试试看修改成员字段之后，再来调用此方法： 123456789try &#123; Object obj = clazz.newInstance(); Field field = clazz.getField(&quot;text&quot;); //获取成员变量 String text; field.set(obj, &quot;华强&quot;); Method method = clazz.getMethod(&quot;test&quot;, String.class); //获取我们定义的test(String str)方法 method.invoke(obj, &quot;哥们这瓜多少钱一斤？&quot;);&#125;catch (Exception e)&#123; e.printStackTrace();&#125; 通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。 注解其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 预设注解JDK预设了以下注解，作用于代码： @Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 元注解元注解是作用于注解上的注解，用于我们编写自定义的注解： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。 既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123;&#125; 这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上： 1234567@Testpublic class Main &#123; @Test public static void main(String[] args) &#123; &#125;&#125; 这样，一个最简单的注解就被我们创建了。 注解的使用我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型： 12345@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; String value();&#125; 默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入： 12345@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; String test();&#125; 123456public class Main &#123; @Test(test = &quot;&quot;) public static void main(String[] args) &#123; &#125;&#125; 我们也可以使用default关键字来为这些属性指定默认值： 12345@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; String value() default &quot;都看到这里了，给个三连吧！&quot;;&#125; 当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？ 12345@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; String[] value();&#125; 当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组： 1234@Test(&quot;关注点了吗&quot;)public static void main(String[] args) &#123;&#125; 123456public class Main &#123; @Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;) //多个值时就使用花括号括起来 public static void main(String[] args) &#123; &#125;&#125; 反射获取注解既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制： 123456789public static void main(String[] args) &#123; Class&lt;Student&gt; clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) &#123; System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 &#125;&#125; 通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解： 123456789public static void main(String[] args) throws NoSuchMethodException &#123; Class&lt;Student&gt; clazz = Student.class; for (Annotation annotation : clazz.getMethod(&quot;test&quot;).getAnnotations()) &#123; System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 &#125;&#125; 无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。 所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。","categories":[],"tags":[]}],"categories":[],"tags":[]}